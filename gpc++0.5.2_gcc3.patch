diff -urN gpc++0.5.2_oryg/ant/ant.cc gpc++0.5.2/ant/ant.cc
--- gpc++0.5.2_oryg/ant/ant.cc	1997-02-16 13:51:15.000000000 +0100
+++ gpc++0.5.2/ant/ant.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,297 +0,0 @@
-
-// ant.cc
-
-/* ---------------------------------------------------------------
-
-The Artificial Ant Problem
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-// Credits also go to Adam Fraser
-
-#include <iostream.h>
-#include <fstream.h>
-#include <strstream.h>
-
-#include <stdlib.h>
-#include <new.h>    // For the new-handler
-
-// Include header file of genetic programming system.
-#include "gp.h" 
-#include "gpconfig.h"
-
-#include "ant.h" 
-
-
-
-// Factor to multiply the length with (for the fitness calculation)
-double lengthFactor=1/1000.0;
-
-// Define configuration parameters and the neccessary array to
-// read/write the configuration to a file. If you need more variables,
-// just add them below and insert an entry in the configArray.
-GPVariables cfg;
-char *InfoFileName="data";
-int energy;
-struct GPConfigVarInformation configArray[]=
-{
-  {"PopulationSize", DATAINT, &cfg.PopulationSize},
-  {"NumberOfGenerations", DATAINT, &cfg.NumberOfGenerations},
-  {"CrossoverProbability", DATADOUBLE, &cfg.CrossoverProbability},
-  {"CreationrProbability", DATADOUBLE, &cfg.CreationProbability},
-  {"CreationType", DATAINT, &cfg.CreationType},
-  {"MaximumDepthForCreation", DATAINT, &cfg.MaximumDepthForCreation},
-  {"MaximumDepthForCrossover", DATAINT, &cfg.MaximumDepthForCrossover},
-  {"SelectionType", DATAINT, &cfg.SelectionType},
-  {"TournamentSize", DATAINT, &cfg.TournamentSize},
-  {"DemeticGrouping", DATAINT, &cfg.DemeticGrouping},
-  {"DemeSize", DATAINT, &cfg.DemeSize},
-  {"DemeticMigProbability", DATADOUBLE, &cfg.DemeticMigProbability},
-  {"SwapMutationProbability", DATADOUBLE, &cfg.SwapMutationProbability},
-  {"ShrinkMutationProbability", DATADOUBLE, &cfg.ShrinkMutationProbability},
-  {"AddBestToNewPopulation", DATAINT, &cfg.AddBestToNewPopulation},
-  {"SteadyState", DATAINT, &cfg.SteadyState},
-  {"InfoFileName", DATASTRING, &InfoFileName},
-  {"LengthFactor", DATADOUBLE, &lengthFactor},
-  {"Energy", DATAINT, &energy},
-  {"", DATAINT, NULL}
-};
-
-// The ant on the trail
-Ant ant;
-
-// Used for printing the trail to a file during evaluation
-int printAnt=0;
-ofstream antFile;
-
-
-
-// We have the freedom to define this function in any way we like.
-// This function evaluates the fitness of a genetic tree and is
-// recursive of course.
-int MyGene::evaluate ()
-{
-  int result, sum;
-  switch (node->value ())
-    {
-
-    case LEFT: 
-      // Turn left and return 0
-      ant.left ();
-      return 0;
-      
-    case RIGHT:
-      // Turn right and return 0
-      ant.right ();
-      return 0;
-      
-    case FORWARD:
-      // Move forward
-      result=ant.forward ();
-
-      // Print the ant?
-      if (printAnt)
-	antFile << ant << '\n' << '\n';
-
-      // Return whether there was food
-      return result;
-      
-    case IFFOODAHEAD:
-      // If thereis a food in the direction you are facing evaluate
-      // the first branch otherwise evolve the second branch
-      if (ant.isFoodAhead ())    
-	return NthMyChild(0)->evaluate ();
-      else
-	return NthMyChild(1)->evaluate ();
-      
-    case PROG2:
-      // Evaluate both children
-      sum=NthMyChild(0)->evaluate ();
-      sum+=NthMyChild(1)->evaluate ();
-      return sum;
-      
-    case PROG3:
-      // Evaluate all three children
-      sum=NthMyChild(0)->evaluate ();
-      sum+=NthMyChild(1)->evaluate ();
-      sum+=NthMyChild(2)->evaluate ();
-      return sum;
-      
-    default: 
-      GPExitSystem ("MyGene::evaluate", "Undefined function value");
-    }
-  
-  // We should never reach this point
-  return 0;
-}
-
-
-
-// Evaluate the fitness of a GP and save it into the class variable
-// fitness.
-void MyGP::evaluate ()
-{
-  // Prepare ant for moving
-  ant.reset (energy);
-
-  // Print the ant?
-  if (printAnt)
-    antFile << ant << '\n' << '\n';
-
-  // While the ant still has energy evaluate the GP accumulating the
-  // fitness.  If, however, the whole trail is eaten, we can stop the
-  // evaluation to speed things up, except we want to have a printout
-  // of the ant's movements.
-  int rawFitness=0;
-  while ((ant.energy>0) && 
-	 ((rawFitness<ant.maxFood) || printAnt))
-    rawFitness+=NthMyGene (0)->evaluate ();
-
-  // Save standardized fitness in object.  Add square times the tree
-  // length multiplied with a factor, to go for small trees, and (most
-  // important) to save memory.
-  stdFitness=(ant.maxFood-rawFitness)+length()*length()*lengthFactor;
-}
-
-
-
-// Create function and terminal set
-void createNodeSet (GPAdfNodeSet& adfNs)
-{
-  // Reserve space for the node sets.  No ADF's, e.g. only one node
-  // set.
-  adfNs.reserveSpace (1);
-  
-  // Now define the function and terminal set for each ADF and place
-  // function/terminal sets into overall ADF container
-  GPNodeSet& ns=*new GPNodeSet (6);
-  adfNs.put (0, ns);
-  
-  // Define functions/terminals and place them into the appropriate
-  // sets. Terminals take two arguments, functions three (the third
-  // parameter is the number of arguments the function has)
-  ns.putNode (*new GPNode (LEFT, "LEFT"));
-  ns.putNode (*new GPNode (RIGHT, "RIGHT"));
-  ns.putNode (*new GPNode (FORWARD, "FORWARD"));
-  ns.putNode (*new GPNode (IFFOODAHEAD, "IFFOODAHEAD", 2));
-  ns.putNode (*new GPNode (PROG2, "PROG2", 2));
-  ns.putNode (*new GPNode (PROG3, "PROG3", 3));
-}
-
-
-
-void newHandler ()
-{
-  cerr << "\nFatal error: Out of memory." << endl;
-  exit (1);
-}
-
-
-
-int main ()
-{
-  // We set up a new-handler, because we might need a lot of memory,
-  // and we don't know it's there.
-  set_new_handler (newHandler);
-  
-  // Init GP system.
-  GPInit (1, -1);
-  
-  // Read configuration file. The defaults will be overwritten by the
-  // configuration file when read. If it doesn't exist, the defaults
-  // will be written to the file.
-  GPConfiguration config (cout, "ant.ini", configArray);
-
-  // Open the main output file for data, trail and statistics file.
-  // First set up names for data file.  Remember we should delete the
-  // string we got from the stream, well, just a few wasted bytes
-  ostrstream strOutFile, strStatFile, strAntFile;
-  strOutFile  << InfoFileName << ".dat" << ends;
-  strStatFile << InfoFileName << ".stc" << ends;
-  strAntFile << InfoFileName << ".ant" << ends;
-  ofstream fout (strOutFile.str());
-  ofstream bout (strStatFile.str());
-  
-  // Print the configuration
-  fout << cfg << endl;
-  cout << cfg << endl;
-  
-  // Create the adf function/terminal set and print it out.
-  GPAdfNodeSet adfNs;
-  createNodeSet (adfNs);
-  cout << adfNs << endl; 
-  fout << adfNs << endl;  
-  
-  // Read the trail
-  ant.readTrail ("santafe.trl");
-
-  // Create a population with this configuration
-  cout << "Creating initial population ..." << endl;
-  MyPopulation* pop=new MyPopulation (cfg, adfNs);
-  pop->create ();
-  cout << "Ok." << endl;
-  pop->createGenerationReport (1, 0, fout, bout);
-  
-  // This next for statement is the actual genetic programming system
-  // which is in essence just repeated reproduction and crossover loop
-  // through all the generations ...
-  MyPopulation* newPop=NULL;
-  for (int gen=1; gen<=cfg.NumberOfGenerations; gen++)
-    {
-      // Create a new generation from the old one by applying the
-      // genetic operators
-      if (!cfg.SteadyState)
-	newPop=new MyPopulation (cfg, adfNs);
-      pop->generate (*newPop);
-      
-      // Delete the old generation and make the new the old one
-      if (!cfg.SteadyState)
-	{
-	  delete pop;
-	  pop=newPop;
-	}
-
-      // Create a report of this generation and how well it is doing
-      pop->createGenerationReport (0, gen, fout, bout);
-    }
-  
-  // Print trail while evaluating the best one of the last generation
-  printAnt=1;
-  antFile.open (strAntFile.str());
-  pop->NthMyGP(pop->bestOfPopulation)->evaluate();
-  antFile.close ();
-
-  cout << "\nResults are in " 
-       << InfoFileName << ".dat, " 
-       << InfoFileName << ".ant, " 
-       << InfoFileName << ".stc." << endl;
-  
-  return 0;
-}
diff -urN gpc++0.5.2_oryg/ant/ant.h gpc++0.5.2/ant/ant.h
--- gpc++0.5.2_oryg/ant/ant.h	1997-02-16 13:51:16.000000000 +0100
+++ gpc++0.5.2/ant/ant.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,177 +0,0 @@
-
-// ant.h
-
-/* ---------------------------------------------------------------
-
-The Artificial Ant Problem
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-// Identifiers for functions and terminals
-const int LEFT=0;        // Turn left
-const int RIGHT=1;       // Turn right
-const int FORWARD=2;     // Move forward
-const int IFFOODAHEAD=3; // If food is ahead
-const int PROG2=4;       // Execute two arguments, return sum
-const int PROG3=5;       // Execute three arguments, return sum
-
-// What character in the trail file means what?
-const char NOTHING='.';
-const char FOOD='X';
-const char GAP='O';
-
-// The size of the trail
-const int worldHorizontal=32;
-const int worldVertical=32;
-
-
-
-// A structure to hold the position of the ant
-struct position {
-  int x, y;
-};
-
-
-
-// A class for our ant on the trail
-class Ant
-{
-public:
-  void readTrail (char *fname);
-
-  void reset (int energy_);
-
-  void left ();
-  void right ();
-  int forward ();
-  position forwardPosition ();
-
-  int isFoodAhead ();
-
-  friend ostream& operator << (ostream &os, Ant &ant);
-
-  // The world the ant is moving in
-  unsigned char world [worldHorizontal][worldVertical];
-  unsigned char constantWorld [worldHorizontal][worldVertical];
-
-  // Current position of ant
-  position pos;
-
-  // Direction the ant is facing (value 0-3) and energy left to move
-  int direction, energy;
-
-  // The maximum amount of food (or fitness) that can be reached
-  int maxFood;
-};
-
-
-
-// We are now inheriting the classes we want to change.  These are
-// usually the class GPGene, GP and GPPopulation.  Read the GP
-// documentation for what has to be done when inheriting from the GP
-// classes.  Load and save is not implemented.
-
-class MyGP;
-
-class MyGene : public GPGene
-{
-public:
-  // The constructor
-  MyGene (GPNode& gpo) : GPGene (gpo) { }
-
-  // Copy constructor and the function duplicate used by the container
-  // class
-  MyGene (const MyGene& gpo) : GPGene (gpo) { }
-  virtual GPObject& duplicate () { return *(new MyGene(*this)); }
-
-  // We have to overwrite this function to create the objects of our
-  // own class MyGene
-  virtual GPGene* createChild (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  // Just an easy way to access the children of the node
-  MyGene* NthMyChild (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-
-  int evaluate ();
-};
-
-
-
-class MyGP : public GP 
-{
-public:
-  // The constructor
-  MyGP (int genes) : GP (genes) { }
-
-  // Copy constructor and the function duplicate used by the container
-  // class
-  MyGP (MyGP& gpo) : GP (gpo) { }
-  virtual GPObject& duplicate () { return *(new MyGP(*this)); }
-
-  // We have to overwrite this function to create the objects of our
-  // own class MyGene
-  virtual GPGene* createGene (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  // Just an easy way to access the trees of the GP
-  MyGene* NthMyGene (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-
-  virtual void evaluate ();
-};
-
-
-
-class MyPopulation : public GPPopulation
-{
-public:
-  // The constructor
-  MyPopulation (GPVariables& GPVar_, GPAdfNodeSet& adfNs_) : 
-    GPPopulation (GPVar_, adfNs_) {}
-
-  // Copy constructor and the function duplicate used by the container
-  // class
-  MyPopulation (MyPopulation& gpo) : GPPopulation(gpo) {}
-  virtual GPObject& duplicate () { return *(new MyPopulation(*this)); }
-
-  // Don't check for ultimate diversity as it takes a long time.
-  // Accept every created GP
-  virtual int checkForValidCreation (GP&) { return 1; }
-
-  // Just an easy way to access the GPs of the population
-  MyGP* NthMyGP (int n) {
-    return (MyGP*) GPContainer::Nth (n); }
-
-  // We have to overwrite this function to create the objects of our
-  // own GP class MyGP
-  virtual GP* createGP (int numOfGenes) { return new MyGP (numOfGenes); }
-};
-
diff -urN gpc++0.5.2_oryg/ant/ant.ini gpc++0.5.2/ant/ant.ini
--- gpc++0.5.2_oryg/ant/ant.ini	1997-02-16 13:51:15.000000000 +0100
+++ gpc++0.5.2/ant/ant.ini	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-
-# Configuration for the artificial ant problem
-
-# GP kernel configuration
-PopulationSize                  = 1000
-NumberOfGenerations             = 50
-CreationType                    = 2
-CrossoverProbability            = 98.0
-CreationProbability             = 1.0
-MaximumDepthForCreation         = 6
-MaximumDepthForCrossover        = 17
-SelectionType                   = 1
-TournamentSize                  = 10
-DemeticGrouping                 = 0
-DemeSize                        = 10
-DemeticMigProbability           = 10.0
-SwapMutationProbability         = 50.0
-ShrinkMutationProbability       = 50.0
-SteadyState			= 1
-AddBestToNewPopulation		= 1
-
-# Program configuration
-InfoFileName                    = data
-Energy				= 600
-LengthFactor			= 0.001
diff -urN gpc++0.5.2_oryg/ant/Makefile gpc++0.5.2/ant/Makefile
--- gpc++0.5.2_oryg/ant/Makefile	1997-02-16 13:51:16.000000000 +0100
+++ gpc++0.5.2/ant/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-
-# Makefile for the artificial ant problem
-
-include		../Makefile.ini
-
-TARGET		= ant
-
-OBJS		= ant.o trail.o
-
-CPPFLAGS	= $(OVERALLCPPFLAGS) -I$(GPINCLUDE)
-LDFLAGS		= $(OVERALLLDFLAGS) -L$(GPLIB) -lgp -lm
-
-# Implicit rule how to compile
-.cc.o:
-	$(CCC) $(CPPFLAGS) -c $<
-
-
-
-all: $(TARGET)
-
-clean:
-	rm -f $(OBJS) data.* *~
-
-superclean: clean
-	rm -f $(TARGET)
-
-strip:
-	strip $(OBJS) $(TARGET)
-
-
-
-$(TARGET) : $(OBJS) $(GPLIBFILE)
-	$(CCC) -o $(TARGET) $(OBJS) $(LDFLAGS) $(LIBS)
-
-
-
-# File dependencies
-ant.o: ant.cc ../include/gp.h ../include/gpconfig.h ant.h
-trail.o: trail.cc ../include/gp.h ant.h
-
-
diff -urN gpc++0.5.2_oryg/ant/santafe.trl gpc++0.5.2/ant/santafe.trl
--- gpc++0.5.2_oryg/ant/santafe.trl	1997-02-16 13:51:16.000000000 +0100
+++ gpc++0.5.2/ant/santafe.trl	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-trail.dat 
-
-data for the trail robot in the ant problem
-
-'.'=nothing, 'X'=trail, 'O'=gap between trails
-
-The following hash is needed by the program to read in the trail
-#
-.XXX............................
-...X............................
-...X....................OXXXOO..
-...X....................X....X..
-...X....................X....X..
-...XXXXOXXXXX.......OXXOO....O..
-............X.......O........X..
-............X.......X........O..
-............X.......X........O..
-............X.......X........X..
-............O.......X........O..
-............X.......O........O..
-............X.......O........X..
-............X.......X........O..
-............X.......X..OOOXXXO..
-............O...OXOOO..X........
-............O...O......O........
-............X...O......O........
-............X...X......OXOOO....
-............X...X..........X....
-............X...X..........O....
-............X...X..........O....
-............X...O......OOOXO....
-............X...O......X........
-.OOXXOOXXXXXO...X...............
-.X..............X...............
-.X..............X...............
-.X.....OXXXXXXXOO...............
-.X.....X........................
-.O.....X........................
-.OXXXXOO........................
-................................
diff -urN gpc++0.5.2_oryg/ant/trail.cc gpc++0.5.2/ant/trail.cc
--- gpc++0.5.2_oryg/ant/trail.cc	1997-02-16 13:51:15.000000000 +0100
+++ gpc++0.5.2/ant/trail.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,217 +0,0 @@
-
-// trail.cc
-
-/* ---------------------------------------------------------------
-
-The Artificial Ant Problem
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1993, 1994 Adam Fraser, 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-// This module is responsible for moving the ant around the artificial
-// world and picking up all the food the ant moves onto
-
-#include <fstream.h>
-
-#include "gp.h"
-#include "ant.h"
-
-
-
-// Read trail from file
-void Ant::readTrail (char* fname)
-{
-  int x=0, y=0;
-
-  ifstream ifs (fname);
-  if (!ifs) 
-    GPExitSystem ("Ant::readTrail", 
-		  "There is no trail data file" );
-  else
-    {
-      char ch=NOTHING;
-
-      // Move to the correct position in the data file: The area below
-      // hash.  The double '!' looks a bit odd, but is needed here as
-      // one of it is an operator redefined by the stream class
-      while (!(!ifs) && ch!='#') 
-	ifs >> ch;
-	
-      while (y<worldVertical)
-	{
-	  // Read character and put it in the constant world member
-	  // variable
-	  ifs >> ch;
-	  if (ch!=NOTHING && ch!=FOOD && ch!=GAP)
-	    GPExitSystem ("Ant::readTrail", 
-			  "Wrong character in trail data file" );
-	  constantWorld[x][y]=ch;
-	    
-	  // Increase index
-	  x++;
-	  if (x==worldHorizontal) 
-	    {
-	      y++;
-	      x=0;
-	    }
-	}
-      if (!ifs) 
-	GPExitSystem ("Ant::readTrail", 
-		      "Error reading trail data file" );
-    }
-
-  // Count the number of available food.  Needed to evaluate the
-  // standardised fitness.
-  for (maxFood=0, x=0; x<worldHorizontal; x++)
-    for (y=0; y<worldVertical; y++)
-      maxFood+=constantWorld[x][y]==FOOD;
-}
-
-
-
-// Reset ant and trail.
-void Ant::reset (int energy_)
-{
-  for (int x=0; x<worldHorizontal; x++)
-    for (int y=0; y<worldVertical; y++)
-      world[x][y]=constantWorld[x][y];
-  energy=energy_;
-  direction=0;     // East
-  pos.x=0; pos.y=0;
-}
-
-
-
-// Print the trail
-ostream& operator << (ostream &os, Ant &ant)
-{
-  for (int y=0; y<worldVertical; y++)
-    {
-      for (int x=0; x<worldHorizontal; x++)
-	{
-	  // Ant's current position?
-	  if (ant.pos.x==x && ant.pos.y==y)
-	    os << 'A';
-	  else
-	    os << ant.world[x][y];
-	}
-      os << '\n';
-    }
-
-  return os;
-}
-
-
-
-// Turn the ant left
-void Ant::left ()
-{
-  if (!energy) 
-    return;
-  energy--;
-  direction = (direction+1) % 4;
-}
-
-
-
-// Turn the ant right
-void Ant::right ()
-{
-  if (!energy) 
-    return;
-  energy--;
-  direction = (direction+3) % 4;
-}
-
-
-
-// Return the final position if the ant would move forward
-position Ant::forwardPosition ()
-{
-  position p=pos;
-
-  switch (direction)
-    {
-    case 0:
-      // East
-      if (p.x<worldHorizontal-1)
-	p.x++;
-      break;
-    case 1:
-      // North
-      if (p.y>0) 
-	p.y--;
-      break;
-    case 2:
-      // West
-      if (p.x>0) 
-	p.x--;
-      break;
-    case 3:
-      // South
-      if (p.y<worldVertical-1)
-	p.y++;
-      break;
-    default:
-      GPExitSystem ("Ant::forwardPosition", "Wrong switch statement");
-    }
-  return p;
-}
-
-
-
-// Move the ant forward and return whether food was found
-int Ant::forward ()
-{
-  if (!energy) 
-    return 0;
-  energy--;
-
-  // New position
-  pos=forwardPosition ();
-
-  // Eat food, if something is there
-  int food=world[pos.x][pos.y]==FOOD;
-  if (food)
-    world[pos.x][pos.y]=NOTHING;
-  return food;
-}
-
-
-
-
-// Return whether there is food ahead
-int Ant::isFoodAhead ()
-{
-  position p=forwardPosition ();
-  return world[p.x][p.y]==FOOD;
-}
-
-
-
diff -urN gpc++0.5.2_oryg/ant/trail.h gpc++0.5.2/ant/trail.h
--- gpc++0.5.2_oryg/ant/trail.h	1997-02-16 13:51:16.000000000 +0100
+++ gpc++0.5.2/ant/trail.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-// trail.hpp
-
-//--------------------------------------------------------------------------
-// This code is a component of Genetic Programming in C++ (Version 0.40)
-// Copyright Adam P. Fraser, 1993,1994
-// This code is released for non-commercial use only.
-// For comments, improvements, additions (or even money !?) contact:
-// Adam Fraser, Postgraduate Section, Dept of Elec & Elec Eng,
-// Maxwell Building, University Of Salford, Salford, M5 4WT, United Kingdom.
-// Internet: a.fraser@eee.salford.ac.uk
-// Tel: (UK) 061 745 5000 x3633
-// Fax: (UK) 061 745 5999
-//--------------------------------------------------------------------------
-
-
-#ifndef TRAIL
-
-#define TRAIL
-
-#define World_Horizontal 32    // defined in trail.cc
-#define World_Vertical  32
-
-extern unsigned short int World[World_Horizontal][World_Vertical];
-extern void CreateWorld( void );
-extern void CreateTrail( void );
-
-#endif
-
-//trail.hpp
diff -urN gpc++0.5.2_oryg/gpc++/gpconfig.h gpc++0.5.2/gpc++/gpconfig.h
--- gpc++0.5.2_oryg/gpc++/gpconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ gpc++0.5.2/gpc++/gpconfig.h	1997-02-16 13:51:20.000000000 +0100
@@ -0,0 +1,76 @@
+
+// gpconfig.h
+
+/* -------------------------------------------------------------------
+
+gpc++ - The Genetic Programming Kernel
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 1, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+
+Copyright 1993, 1994 Adam P. Fraser and 1996, 1997 Thomas Weinbrenner
+
+For comments, improvements, additions (or even money) contact:
+
+Thomas Weinbrenner
+Grauensteinstr. 26
+35789 Laimbach
+Germany
+E-mail: thomasw@emk.e-technik.th-darmstadt.de
+WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
+
+  or 
+
+(Address may be out of date)
+Adam Fraser, Postgraduate Section, Dept of Elec & Elec Eng,
+Maxwell Building, University Of Salford, Salford, M5 4WT, United Kingdom.
+E-mail: a.fraser@eee.salford.ac.uk
+Tel:    (UK) 061 745 5000 x3633
+Fax:    (UK) 061 745 5999
+
+------------------------------------------------------------------- */
+
+#ifndef __GPCONFIG_H
+#define __GPCONFIG_H
+
+enum GPDataType {DATAINT=1, DATAFLOAT, DATADOUBLE, DATASTRING};
+
+struct GPConfigVarInformation {
+  char *name;
+  enum GPDataType typ;
+  void *varPtr;
+};
+
+class GPConfiguration
+{
+public:
+  GPConfiguration (ostream &out, char *fname,
+		   struct GPConfigVarInformation cfg[]);
+  ~GPConfiguration ();
+
+  // Prototype to write the configuration variables to ostream 
+  friend inline ostream& operator << (ostream& o, const GPConfiguration& c)
+  {
+    c.printOn (o);
+    return o;
+  }
+
+private:
+  struct GPConfigVarInformation* saveStruc;
+  void printOn (ostream& o) const;
+};
+
+#endif
+
diff -urN gpc++0.5.2_oryg/gpc++/gp.h gpc++0.5.2/gpc++/gp.h
--- gpc++0.5.2_oryg/gpc++/gp.h	1970-01-01 01:00:00.000000000 +0100
+++ gpc++0.5.2/gpc++/gp.h	2005-06-02 14:48:58.000000000 +0200
@@ -0,0 +1,587 @@
+
+// gp.h
+
+/* -------------------------------------------------------------------
+
+gpc++ - The Genetic Programming Kernel
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 1, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+
+Copyright 1993, 1994 Adam P. Fraser and 1996, 1997 Thomas Weinbrenner
+
+For comments, improvements, additions (or even money) contact:
+
+Thomas Weinbrenner
+Grauensteinstr. 26
+35789 Laimbach
+Germany
+E-mail: thomasw@emk.e-technik.th-darmstadt.de
+WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
+
+  or 
+
+(Address may be out of date)
+Adam Fraser, Postgraduate Section, Dept of Elec & Elec Eng,
+Maxwell Building, University Of Salford, Salford, M5 4WT, United Kingdom.
+E-mail: a.fraser@eee.salford.ac.uk
+Tel:    (UK) 061 745 5000 x3633
+Fax:    (UK) 061 745 5999
+
+------------------------------------------------------------------- */
+
+// Genetic Program class definitions
+
+
+
+#ifndef __GP_H
+#define __GP_H
+
+#include <iostream>
+using namespace std;
+
+
+
+// Version and copyright message
+extern char* GPVersion;
+void GPPrintCopyright (ostream& os);
+
+// Make internal checks or not. Better do it... it saved me a lot of
+// work I can tell.  It results in a speed loss of roughly 3%, that is
+// less than it sounds.  A good, optimising compiler can do much more
+// here.
+#define GPINTERNALCHECK 1
+
+// If an error occurs (GPExitSystem()), a segmentation fault helps
+// debugging the code to find the location that caused the error
+#define GPCREATE_SEGMENTATIONFAULT_ON_ERROR 1
+
+// Random number functions for gp system
+void GPsrand (long);
+long GPrand ();
+int GPRandomPercent (double percent);
+
+// Init and exit
+void GPInit (int printCopyright, long seedRandomGenerator);
+void GPExitSystem (char *functionName, char *errorMessage); 
+
+// Registering for load/save
+class GPObject;
+GPObject* GPCreateRegisteredClassObject (int ID);
+void GPRegisterClass (GPObject* gpo);
+void GPRegisterKernelClasses ();
+
+// Every class gets an unique identification number that is returned
+// by the function isA().
+#define GPObjectID       1
+#define GPContainerID    2
+#define GPNodeID         3
+#define GPNodeSetID      4
+#define GPAdfNodeSetID   5
+#define GPVariablesID    6
+#define GPGeneID         7
+#define GPID             8
+#define GPPopulationID   9
+#define GPUserID        50
+
+
+
+// ------------------------------------------------------------------
+
+
+
+// The base class for all other classes.  This is an abstract class.
+// The destructor is virtual.
+
+class GPObject
+{
+public:
+  GPObject () {}
+  virtual ~GPObject () {}
+
+  GPObject (const GPObject&) {}
+  // Duplicate object. This function must be provided by every
+  // inheriting class!!!
+  virtual GPObject& duplicate ()=0;
+
+  virtual int isA ()=0;
+  virtual char* load (istream& is)=0;
+  virtual void save (ostream& os)=0;
+  virtual GPObject* createObject()=0;
+
+  // Print function. It's virtual, so only one operator << is needed.
+  virtual void printOn (ostream& os)=0;
+};
+
+// Print operator for all classes that inherit from GPObject
+inline ostream& operator << (ostream& os, GPObject& gpo)
+{
+  gpo.printOn (os);
+  return os;
+}
+
+
+
+class GPContainer : public GPObject
+{
+public:
+  GPContainer ();
+  GPContainer (int numObjects);
+  virtual ~GPContainer ();
+
+  GPContainer (const GPContainer& gpc);
+  virtual GPObject& duplicate () { return *(new GPContainer(*this)); }
+
+  virtual void printOn (ostream& os);
+
+  void reserveSpace (int numObjects);
+
+  int containerSize() const { return contSize; }
+
+  GPObject* Nth (int n) const;
+  GPObject** getPointerAddress (int n) const;
+  void put (int n, GPObject& gpo);
+  GPObject& get (int n);
+
+  virtual int isA () { return GPContainerID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  virtual GPObject* createObject() { return new GPContainer; }
+
+  GPContainer& operator = (GPContainer& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+
+protected:
+  void deleteContainer ();
+
+  // The actual container is an array of pointers to GPObject
+  GPObject** container;
+  // The container size
+  int contSize;
+};
+
+
+
+// ------------------------------------------------------------------
+
+
+
+class GPNode : public GPObject
+{
+public:
+  GPNode () { nodeValue=0; numOfArgs=0; representation=0; }
+  GPNode (int nVal, char* str, int args=0) : nodeValue(nVal), 
+      numOfArgs(args) { representation=copyString (str); }
+  virtual ~GPNode () { delete [] representation; }
+
+  GPNode (const GPNode& gpo);
+  virtual GPObject& duplicate () { return *(new GPNode(*this)); }
+
+  virtual void printOn (ostream& os) { os << representation; }
+
+  int value () { return nodeValue; }
+  int isFunction () { return numOfArgs!=0; }
+  int isTerminal () { return numOfArgs==0; }
+  int arguments () { return numOfArgs; }
+
+  virtual int isA () { return GPNodeID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  virtual GPObject* createObject() { return new GPNode; }
+
+  GPNode& operator = (GPNode& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+
+protected:
+  // The nodes numerical value, the number of arguments it takes (0 if
+  // it is a terminal) and its string representation.  We operate on a
+  // duplicate
+  int nodeValue;
+  int numOfArgs;
+  char* representation;
+
+  char *copyString (char *s);
+};
+
+
+
+class GPNodeSet : public GPContainer
+{
+public:
+  GPNodeSet () { numFunctions=0; numTerminals=0; }
+  GPNodeSet (int numOfNodes) : GPContainer (numOfNodes) {
+    numFunctions=0; numTerminals=0; }
+
+  GPNodeSet (const GPNodeSet& gpo) : GPContainer(gpo) { 
+    numFunctions=gpo.numFunctions; numTerminals=gpo.numTerminals; }
+  virtual GPObject& duplicate () { return *(new GPNodeSet(*this)); }
+
+  virtual void put (int, GPObject&);
+  virtual void putNode (GPNode& gpo);
+
+  virtual void printOn (ostream& os);
+
+  virtual GPNode* searchForNode (int value);
+  GPNode* NthNode (int n) {
+    return (GPNode*) GPContainer::Nth (n); }
+
+  virtual GPNode& chooseFunction();
+  virtual GPNode& chooseTerminal();
+  virtual GPNode* chooseNodeWithArgs (int args);
+
+  virtual int isA () { return GPNodeSetID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  virtual GPObject* createObject() { return new GPNodeSet; }
+
+  GPNodeSet& operator = (GPNodeSet& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+
+protected:
+  // Container contains functions from 0..numFunctions-1 and terminals
+  // from containerSize()-1-numTerminals..containerSize()-1
+  int numFunctions, numTerminals;
+};
+
+
+
+class GPAdfNodeSet : public GPContainer
+{
+public:
+  GPAdfNodeSet () {}
+  GPAdfNodeSet (int numOfTrees) : GPContainer(numOfTrees) {}
+
+  GPAdfNodeSet (const GPAdfNodeSet& gpo) : GPContainer(gpo) {}
+  virtual GPObject& duplicate () { return *(new GPAdfNodeSet(*this)); }
+
+  // As we have no variables, we leave load and save to our container
+  // class
+  virtual int isA () { return GPAdfNodeSetID; }
+  virtual GPObject* createObject() { return new GPAdfNodeSet; }
+
+  virtual void printOn (ostream& os);
+
+  GPNodeSet* NthNodeSet (int n) { 
+    return (GPNodeSet*) GPContainer::Nth (n); }
+
+  GPAdfNodeSet& operator = (GPAdfNodeSet& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+};
+
+
+
+// ------------------------------------------------------------------
+
+
+
+// Prototypes
+class GP;
+class GPPopulation;
+
+// These definitions are for the different types of creation method
+// available to the genetic programming system and are set by the user.
+enum GPCreationType {
+  // variable tree to maxdepth creation
+  GPVariable=0,
+  // all branches go to maxdepth creation
+  GPGrow,
+  // half and half of the the two types shown below. This is the
+  // creation method of Koza...
+  GPRampedHalf,
+  GPRampedVariable,
+  // grow branches equal to max depth ofcreation with this
+  // parameter being increased as we move through population
+  GPRampedGrow,
+  // Whatever the user thinks. We haven't implemented this, but the
+  // user can in one of his inherited classes
+  GPUserDefinedCreation};
+
+// Selection types: tournament selection or probabilistic selection.
+enum GPSelectionType {
+  GPProbabilisticSelection=0,
+  GPTournamentSelection,
+  GPUserDefinedSelection};
+
+
+
+class GPVariables : public GPObject
+{
+public:
+  GPVariables ();
+  ~GPVariables () {};
+
+  GPVariables (const GPVariables& gpo);
+  virtual GPObject& duplicate () { return *(new GPVariables(*this)); }
+
+  int PopulationSize,
+    NumberOfGenerations,
+    CreationType,
+    MaximumDepthForCreation,
+    MaximumDepthForCrossover,
+    SelectionType,
+    TournamentSize,
+    DemeticGrouping,
+    DemeSize,
+    AddBestToNewPopulation,
+    SteadyState;
+  double CrossoverProbability, CreationProbability,
+    SwapMutationProbability, ShrinkMutationProbability,
+    DemeticMigProbability;
+
+  virtual void printOn (ostream& os);
+
+  virtual int isA () { return GPVariablesID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  virtual GPObject* createObject() { return new GPVariables; }
+};
+
+
+
+class GPGene : public GPContainer
+{
+public:
+  GPGene () { node=0; }
+  GPGene (GPNode& gpo)
+    : node(&gpo), GPContainer(gpo.arguments()) {}
+
+  GPGene (const GPGene& gpo)
+    : GPContainer (gpo) { node=gpo.node; }
+  virtual GPObject& duplicate () { return *(new GPGene(*this)); }
+
+  virtual GPGene* createChild (GPNode& gpo) {
+    return new GPGene (gpo); }
+
+  virtual int isA () { return GPGeneID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  void resolveNodeValues (GPNodeSet& ns);
+  virtual GPObject* createObject() { return new GPGene; }
+
+  virtual void printOn (ostream& os);
+
+  virtual int isFunction () { return node->isFunction (); }
+  virtual int isTerminal () { return node->isTerminal (); }
+
+  GPNode& geneNode () { return *node; }
+  GPGene* NthChild (int n) {
+    return (GPGene*) GPContainer::Nth (n); }
+  GPGene** findNthNode (GPGene** rootPtr, int findFunction,
+			int &iLengthCount);
+
+  virtual GPGene** choose (GPGene** rootPtr);
+
+  int countFunctions ();
+  GPGene** chooseFunctionNode (GPGene** rootPtr);
+
+  virtual int length ();
+  virtual int depth (int depthSoFar=1);
+
+  virtual void create (enum GPCreationType ctype, int allowabledepth, 
+		       GPNodeSet& ns);
+
+  friend int operator == (GPGene& pg1, GPGene& pg2);
+  virtual int compare (GPGene& g);
+
+  friend class GP;
+
+  GPGene& operator = (GPGene& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+
+protected:
+  // Pointer to Function or Terminal.  It's a good solution (I think)
+  // not to have any specific values in this class, but rather
+  // pointers to the functions.  You can get all the information you
+  // need from them... On the other hand, if we load a gene, we
+  // load/save only the node value.  Another function has to be called
+  // after the load process to convert this value back to a pointer
+  union
+  {
+    GPNode* node;
+    int nodeValue;
+  };
+};
+
+
+
+class GP : public GPContainer
+{
+public:
+  GP () { fitnessValid=0; GPlength=0; GPdepth=0; }
+  GP (int trees) : GPContainer (trees) { fitnessValid=0; 
+    GPlength=0; GPdepth=0; }
+
+  GP (const GP& gpo) : GPContainer(gpo) { stdFitness=gpo.stdFitness; 
+    fitnessValid=gpo.fitnessValid; GPlength=gpo.GPlength; 
+    GPdepth=gpo.GPdepth; }
+  virtual GPObject& duplicate () { return *(new GP(*this)); }
+
+  virtual GPGene* createGene (GPNode& gpo) {
+    return new GPGene (gpo); }
+
+  virtual void printOn (ostream& os);
+
+  GPGene* NthGene (int n) { return (GPGene*) GPContainer::Nth(n); }
+
+  double getFitness () { return stdFitness; }
+  virtual int length () { return GPlength; }
+  virtual int depth () { return GPdepth; }
+  virtual void calcLength ();
+  virtual void calcDepth ();
+
+  virtual int compare (GP& gp);
+  virtual void create (enum GPCreationType ctype, int allowabledepth, 
+		       GPAdfNodeSet& adfNs);
+
+  void shrinkMutation ();
+  void swapMutation (GPAdfNodeSet& adfNs);
+  virtual void mutate (GPVariables& GPVar, GPAdfNodeSet& adfNs);
+  virtual GPContainer& cross (GPContainer* parents, 
+			      int maxdepthforcrossover);
+  virtual void evaluate ();
+
+  virtual int isA () { return GPID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  void resolveNodeValues (GPAdfNodeSet& adfNs);
+  virtual GPObject* createObject() { return new GP; }
+
+  friend class GPPopulation;
+
+  GP& operator = (GP& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+
+protected:
+  // The standardized fitness (positive numbers, and 0.0 is best) and
+  // a flag whether the fitness of this GP-object is already
+  // calculated or not. The flag must be set to 0 by any operation
+  // that changes the GP (for example the crossover and mutation), but
+  // not by reproduction. This can save us a lot of time.
+  int fitnessValid;
+  double stdFitness;
+
+  // Length and depth of GP
+  int GPlength, GPdepth;
+};
+
+
+
+// A structure to simplify the parameter exchange for all the
+// selection functions.  It holds the range for which the selection
+// has to take place, and a flag that determines whether this is the
+// first selection of that particular deme.  This is used to speed up
+// the selection process for the probablistic selection.
+struct GPPopulationRange
+{
+  int startIx, endIx;
+  int firstSelectionPerDeme;
+};
+
+
+
+class GPPopulation : public GPContainer
+{
+public:
+  GPPopulation () {}
+  GPPopulation (GPVariables& GPVar_, GPAdfNodeSet& adfNs_) : 
+    adfNs(&adfNs_), GPVar(GPVar_) {}
+
+  GPPopulation (const GPPopulation& gpo) : GPContainer(gpo), adfNs(gpo.adfNs)
+    { GPVar=gpo.GPVar; avgFitness=gpo.avgFitness; 
+    avgLength=gpo.avgLength; avgDepth=gpo.avgDepth; }
+  virtual GPObject& duplicate () { return *(new GPPopulation(*this)); }
+
+  virtual void printOn (ostream& os);
+
+  GP* NthGP (int n) { return (GP*) GPContainer::Nth (n); }
+
+  virtual int checkForValidCreation (GP& gpo);
+  virtual void create ();
+  virtual GP* createGP (int numOfTrees) { return new GP (numOfTrees); }
+
+  double totalFitness ();
+  long totalLength ();
+  long totalDepth ();
+
+  virtual void tournamentSelection (int *selection, int numToSelect,
+				    int selectWorst, 
+				    GPPopulationRange& range);
+  virtual void probabilisticSelection (int *selection, int numToSelect, 
+				       int selectWorst, 
+				       GPPopulationRange& range);
+  virtual void selectIndices (int *selection, int numToSelect, 
+			      int selectWorst, GPPopulationRange& range);
+  virtual GPContainer* select (int numToSelect, GPPopulationRange& range);
+  virtual GPContainer* selectParents (GPPopulationRange& range);
+  virtual void calculateStatistics ();
+  virtual void evaluate();
+
+  virtual void createGenerationReport (int printLegend, int generation,
+				       ostream& fout, ostream& bout);
+  GPContainer* evolution (GPPopulationRange& range);
+  virtual void generate (GPPopulation& newPop);
+  virtual void demeticMigration ();
+
+  virtual int isA () { return GPID; }
+  virtual char* load (istream& is);
+  virtual void save (ostream& os);
+  void setNodeSets (GPAdfNodeSet& adfNs_);
+  virtual GPObject* createObject() { return new GPPopulation; }
+
+  // Index to the best and worst of a population. Only valid after a
+  // call to calculateStatistics (done by evaluate())
+  int bestOfPopulation, worstOfPopulation;
+
+  GPPopulation& operator = (GPPopulation& gpo) {
+    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
+    return gpo; }
+
+protected:
+  // We have to save the function and terminal sets here, because we
+  // need them later
+  GPAdfNodeSet* adfNs;
+
+  // These are important variables used for the configuration of the
+  // whole GP system
+  GPVariables GPVar;
+
+  // Average values: some useful statistics. Calculated by
+  // calculateStatistics() (which is called by evaluate())
+  double avgFitness, avgLength, avgDepth;
+
+private:
+  // These variables are needed only for the probablistic selection
+  // method and are calculated anew for every deme or population.  So
+  // they need not to be load/saved.  We save the summed inverse
+  // fitness and the summed fitness of the deme/population in a static
+  // variable and determine whether we have to calculate it again each
+  // call depending on variable firstCallPerDeme (parameter to the
+  // selection function).
+  double invSumFitness;
+  double sumFitness;
+
+  int checkForDiversity (GP& gp);
+};
+
+
+
+#endif
+
diff -urN gpc++0.5.2_oryg/include/gpconfig.h gpc++0.5.2/include/gpconfig.h
--- gpc++0.5.2_oryg/include/gpconfig.h	1997-02-16 13:51:20.000000000 +0100
+++ gpc++0.5.2/include/gpconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-
-// gpconfig.h
-
-/* -------------------------------------------------------------------
-
-gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-
-Copyright 1993, 1994 Adam P. Fraser and 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
-  or 
-
-(Address may be out of date)
-Adam Fraser, Postgraduate Section, Dept of Elec & Elec Eng,
-Maxwell Building, University Of Salford, Salford, M5 4WT, United Kingdom.
-E-mail: a.fraser@eee.salford.ac.uk
-Tel:    (UK) 061 745 5000 x3633
-Fax:    (UK) 061 745 5999
-
-------------------------------------------------------------------- */
-
-#ifndef __GPCONFIG_H
-#define __GPCONFIG_H
-
-enum GPDataType {DATAINT=1, DATAFLOAT, DATADOUBLE, DATASTRING};
-
-struct GPConfigVarInformation {
-  char *name;
-  enum GPDataType typ;
-  void *varPtr;
-};
-
-class GPConfiguration
-{
-public:
-  GPConfiguration (ostream &out, char *fname,
-		   struct GPConfigVarInformation cfg[]);
-  ~GPConfiguration ();
-
-  // Prototype to write the configuration variables to ostream 
-  friend inline ostream& operator << (ostream& o, const GPConfiguration& c)
-  {
-    c.printOn (o);
-    return o;
-  }
-
-private:
-  struct GPConfigVarInformation* saveStruc;
-  void printOn (ostream& o) const;
-};
-
-#endif
-
diff -urN gpc++0.5.2_oryg/include/gp.h gpc++0.5.2/include/gp.h
--- gpc++0.5.2_oryg/include/gp.h	1997-02-16 13:51:20.000000000 +0100
+++ gpc++0.5.2/include/gp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,586 +0,0 @@
-
-// gp.h
-
-/* -------------------------------------------------------------------
-
-gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-
-Copyright 1993, 1994 Adam P. Fraser and 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
-  or 
-
-(Address may be out of date)
-Adam Fraser, Postgraduate Section, Dept of Elec & Elec Eng,
-Maxwell Building, University Of Salford, Salford, M5 4WT, United Kingdom.
-E-mail: a.fraser@eee.salford.ac.uk
-Tel:    (UK) 061 745 5000 x3633
-Fax:    (UK) 061 745 5999
-
-------------------------------------------------------------------- */
-
-// Genetic Program class definitions
-
-
-
-#ifndef __GP_H
-#define __GP_H
-
-#include <iostream.h>
-
-
-
-// Version and copyright message
-extern char* GPVersion;
-void GPPrintCopyright (ostream& os);
-
-// Make internal checks or not. Better do it... it saved me a lot of
-// work I can tell.  It results in a speed loss of roughly 3%, that is
-// less than it sounds.  A good, optimising compiler can do much more
-// here.
-#define GPINTERNALCHECK 1
-
-// If an error occurs (GPExitSystem()), a segmentation fault helps
-// debugging the code to find the location that caused the error
-#define GPCREATE_SEGMENTATIONFAULT_ON_ERROR 1
-
-// Random number functions for gp system
-void GPsrand (long);
-long GPrand ();
-int GPRandomPercent (double percent);
-
-// Init and exit
-void GPInit (int printCopyright, long seedRandomGenerator);
-void GPExitSystem (char *functionName, char *errorMessage); 
-
-// Registering for load/save
-class GPObject;
-GPObject* GPCreateRegisteredClassObject (int ID);
-void GPRegisterClass (GPObject* gpo);
-void GPRegisterKernelClasses ();
-
-// Every class gets an unique identification number that is returned
-// by the function isA().
-#define GPObjectID       1
-#define GPContainerID    2
-#define GPNodeID         3
-#define GPNodeSetID      4
-#define GPAdfNodeSetID   5
-#define GPVariablesID    6
-#define GPGeneID         7
-#define GPID             8
-#define GPPopulationID   9
-#define GPUserID        50
-
-
-
-// ------------------------------------------------------------------
-
-
-
-// The base class for all other classes.  This is an abstract class.
-// The destructor is virtual.
-
-class GPObject
-{
-public:
-  GPObject () {}
-  virtual ~GPObject () {}
-
-  GPObject (const GPObject&) {}
-  // Duplicate object. This function must be provided by every
-  // inheriting class!!!
-  virtual GPObject& duplicate ()=0;
-
-  virtual int isA ()=0;
-  virtual char* load (istream& is)=0;
-  virtual void save (ostream& os)=0;
-  virtual GPObject* createObject()=0;
-
-  // Print function. It's virtual, so only one operator << is needed.
-  virtual void printOn (ostream& os)=0;
-};
-
-// Print operator for all classes that inherit from GPObject
-inline ostream& operator << (ostream& os, GPObject& gpo)
-{
-  gpo.printOn (os);
-  return os;
-}
-
-
-
-class GPContainer : public GPObject
-{
-public:
-  GPContainer ();
-  GPContainer (int numObjects);
-  virtual ~GPContainer ();
-
-  GPContainer (const GPContainer& gpc);
-  virtual GPObject& duplicate () { return *(new GPContainer(*this)); }
-
-  virtual void printOn (ostream& os);
-
-  void reserveSpace (int numObjects);
-
-  int containerSize() const { return contSize; }
-
-  GPObject* Nth (int n) const;
-  GPObject** getPointerAddress (int n) const;
-  void put (int n, GPObject& gpo);
-  GPObject& get (int n);
-
-  virtual int isA () { return GPContainerID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  virtual GPObject* createObject() { return new GPContainer; }
-
-  GPContainer& operator = (GPContainer& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-
-protected:
-  void deleteContainer ();
-
-  // The actual container is an array of pointers to GPObject
-  GPObject** container;
-  // The container size
-  int contSize;
-};
-
-
-
-// ------------------------------------------------------------------
-
-
-
-class GPNode : public GPObject
-{
-public:
-  GPNode () { nodeValue=0; numOfArgs=0; representation=0; }
-  GPNode (int nVal, char* str, int args=0) : nodeValue(nVal), 
-      numOfArgs(args) { representation=copyString (str); }
-  virtual ~GPNode () { delete [] representation; }
-
-  GPNode (const GPNode& gpo);
-  virtual GPObject& duplicate () { return *(new GPNode(*this)); }
-
-  virtual void printOn (ostream& os) { os << representation; }
-
-  int value () { return nodeValue; }
-  int isFunction () { return numOfArgs!=0; }
-  int isTerminal () { return numOfArgs==0; }
-  int arguments () { return numOfArgs; }
-
-  virtual int isA () { return GPNodeID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  virtual GPObject* createObject() { return new GPNode; }
-
-  GPNode& operator = (GPNode& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-
-protected:
-  // The nodes numerical value, the number of arguments it takes (0 if
-  // it is a terminal) and its string representation.  We operate on a
-  // duplicate
-  int nodeValue;
-  int numOfArgs;
-  char* representation;
-
-  char *copyString (char *s);
-};
-
-
-
-class GPNodeSet : public GPContainer
-{
-public:
-  GPNodeSet () { numFunctions=0; numTerminals=0; }
-  GPNodeSet (int numOfNodes) : GPContainer (numOfNodes) {
-    numFunctions=0; numTerminals=0; }
-
-  GPNodeSet (const GPNodeSet& gpo) : GPContainer(gpo) { 
-    numFunctions=gpo.numFunctions; numTerminals=gpo.numTerminals; }
-  virtual GPObject& duplicate () { return *(new GPNodeSet(*this)); }
-
-  virtual void put (int, GPObject&);
-  virtual void putNode (GPNode& gpo);
-
-  virtual void printOn (ostream& os);
-
-  virtual GPNode* searchForNode (int value);
-  GPNode* NthNode (int n) {
-    return (GPNode*) GPContainer::Nth (n); }
-
-  virtual GPNode& chooseFunction();
-  virtual GPNode& chooseTerminal();
-  virtual GPNode* chooseNodeWithArgs (int args);
-
-  virtual int isA () { return GPNodeSetID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  virtual GPObject* createObject() { return new GPNodeSet; }
-
-  GPNodeSet& operator = (GPNodeSet& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-
-protected:
-  // Container contains functions from 0..numFunctions-1 and terminals
-  // from containerSize()-1-numTerminals..containerSize()-1
-  int numFunctions, numTerminals;
-};
-
-
-
-class GPAdfNodeSet : public GPContainer
-{
-public:
-  GPAdfNodeSet () {}
-  GPAdfNodeSet (int numOfTrees) : GPContainer(numOfTrees) {}
-
-  GPAdfNodeSet (const GPAdfNodeSet& gpo) : GPContainer(gpo) {}
-  virtual GPObject& duplicate () { return *(new GPAdfNodeSet(*this)); }
-
-  // As we have no variables, we leave load and save to our container
-  // class
-  virtual int isA () { return GPAdfNodeSetID; }
-  virtual GPObject* createObject() { return new GPAdfNodeSet; }
-
-  virtual void printOn (ostream& os);
-
-  GPNodeSet* NthNodeSet (int n) { 
-    return (GPNodeSet*) GPContainer::Nth (n); }
-
-  GPAdfNodeSet& operator = (GPAdfNodeSet& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-};
-
-
-
-// ------------------------------------------------------------------
-
-
-
-// Prototypes
-class GP;
-class GPPopulation;
-
-// These definitions are for the different types of creation method
-// available to the genetic programming system and are set by the user.
-enum GPCreationType {
-  // variable tree to maxdepth creation
-  GPVariable=0,
-  // all branches go to maxdepth creation
-  GPGrow,
-  // half and half of the the two types shown below. This is the
-  // creation method of Koza...
-  GPRampedHalf,
-  GPRampedVariable,
-  // grow branches equal to max depth ofcreation with this
-  // parameter being increased as we move through population
-  GPRampedGrow,
-  // Whatever the user thinks. We haven't implemented this, but the
-  // user can in one of his inherited classes
-  GPUserDefinedCreation};
-
-// Selection types: tournament selection or probabilistic selection.
-enum GPSelectionType {
-  GPProbabilisticSelection=0,
-  GPTournamentSelection,
-  GPUserDefinedSelection};
-
-
-
-class GPVariables : public GPObject
-{
-public:
-  GPVariables ();
-  ~GPVariables () {};
-
-  GPVariables (const GPVariables& gpo);
-  virtual GPObject& duplicate () { return *(new GPVariables(*this)); }
-
-  int PopulationSize,
-    NumberOfGenerations,
-    CreationType,
-    MaximumDepthForCreation,
-    MaximumDepthForCrossover,
-    SelectionType,
-    TournamentSize,
-    DemeticGrouping,
-    DemeSize,
-    AddBestToNewPopulation,
-    SteadyState;
-  double CrossoverProbability, CreationProbability,
-    SwapMutationProbability, ShrinkMutationProbability,
-    DemeticMigProbability;
-
-  virtual void printOn (ostream& os);
-
-  virtual int isA () { return GPVariablesID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  virtual GPObject* createObject() { return new GPVariables; }
-};
-
-
-
-class GPGene : public GPContainer
-{
-public:
-  GPGene () { node=0; }
-  GPGene (GPNode& gpo)
-    : node(&gpo), GPContainer(gpo.arguments()) {}
-
-  GPGene (const GPGene& gpo)
-    : GPContainer (gpo) { node=gpo.node; }
-  virtual GPObject& duplicate () { return *(new GPGene(*this)); }
-
-  virtual GPGene* createChild (GPNode& gpo) {
-    return new GPGene (gpo); }
-
-  virtual int isA () { return GPGeneID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  void resolveNodeValues (GPNodeSet& ns);
-  virtual GPObject* createObject() { return new GPGene; }
-
-  virtual void printOn (ostream& os);
-
-  virtual int isFunction () { return node->isFunction (); }
-  virtual int isTerminal () { return node->isTerminal (); }
-
-  GPNode& geneNode () { return *node; }
-  GPGene* NthChild (int n) {
-    return (GPGene*) GPContainer::Nth (n); }
-  GPGene** findNthNode (GPGene** rootPtr, int findFunction,
-			int &iLengthCount);
-
-  virtual GPGene** choose (GPGene** rootPtr);
-
-  int countFunctions ();
-  GPGene** chooseFunctionNode (GPGene** rootPtr);
-
-  virtual int length ();
-  virtual int depth (int depthSoFar=1);
-
-  virtual void create (enum GPCreationType ctype, int allowabledepth, 
-		       GPNodeSet& ns);
-
-  friend int operator == (GPGene& pg1, GPGene& pg2);
-  virtual int compare (GPGene& g);
-
-  friend GP;
-
-  GPGene& operator = (GPGene& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-
-protected:
-  // Pointer to Function or Terminal.  It's a good solution (I think)
-  // not to have any specific values in this class, but rather
-  // pointers to the functions.  You can get all the information you
-  // need from them... On the other hand, if we load a gene, we
-  // load/save only the node value.  Another function has to be called
-  // after the load process to convert this value back to a pointer
-  union
-  {
-    GPNode* node;
-    int nodeValue;
-  };
-};
-
-
-
-class GP : public GPContainer
-{
-public:
-  GP () { fitnessValid=0; GPlength=0; GPdepth=0; }
-  GP (int trees) : GPContainer (trees) { fitnessValid=0; 
-    GPlength=0; GPdepth=0; }
-
-  GP (const GP& gpo) : GPContainer(gpo) { stdFitness=gpo.stdFitness; 
-    fitnessValid=gpo.fitnessValid; GPlength=gpo.GPlength; 
-    GPdepth=gpo.GPdepth; }
-  virtual GPObject& duplicate () { return *(new GP(*this)); }
-
-  virtual GPGene* createGene (GPNode& gpo) {
-    return new GPGene (gpo); }
-
-  virtual void printOn (ostream& os);
-
-  GPGene* NthGene (int n) { return (GPGene*) GPContainer::Nth(n); }
-
-  double getFitness () { return stdFitness; }
-  virtual int length () { return GPlength; }
-  virtual int depth () { return GPdepth; }
-  virtual void calcLength ();
-  virtual void calcDepth ();
-
-  virtual int compare (GP& gp);
-  virtual void create (enum GPCreationType ctype, int allowabledepth, 
-		       GPAdfNodeSet& adfNs);
-
-  void shrinkMutation ();
-  void swapMutation (GPAdfNodeSet& adfNs);
-  virtual void mutate (GPVariables& GPVar, GPAdfNodeSet& adfNs);
-  virtual GPContainer& cross (GPContainer* parents, 
-			      int maxdepthforcrossover);
-  virtual void evaluate ();
-
-  virtual int isA () { return GPID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  void resolveNodeValues (GPAdfNodeSet& adfNs);
-  virtual GPObject* createObject() { return new GP; }
-
-  friend GPPopulation;
-
-  GP& operator = (GP& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-
-protected:
-  // The standardized fitness (positive numbers, and 0.0 is best) and
-  // a flag whether the fitness of this GP-object is already
-  // calculated or not. The flag must be set to 0 by any operation
-  // that changes the GP (for example the crossover and mutation), but
-  // not by reproduction. This can save us a lot of time.
-  int fitnessValid;
-  double stdFitness;
-
-  // Length and depth of GP
-  int GPlength, GPdepth;
-};
-
-
-
-// A structure to simplify the parameter exchange for all the
-// selection functions.  It holds the range for which the selection
-// has to take place, and a flag that determines whether this is the
-// first selection of that particular deme.  This is used to speed up
-// the selection process for the probablistic selection.
-struct GPPopulationRange
-{
-  int startIx, endIx;
-  int firstSelectionPerDeme;
-};
-
-
-
-class GPPopulation : public GPContainer
-{
-public:
-  GPPopulation () {}
-  GPPopulation (GPVariables& GPVar_, GPAdfNodeSet& adfNs_) : 
-    adfNs(&adfNs_), GPVar(GPVar_) {}
-
-  GPPopulation (const GPPopulation& gpo) : GPContainer(gpo), adfNs(gpo.adfNs)
-    { GPVar=gpo.GPVar; avgFitness=gpo.avgFitness; 
-    avgLength=gpo.avgLength; avgDepth=gpo.avgDepth; }
-  virtual GPObject& duplicate () { return *(new GPPopulation(*this)); }
-
-  virtual void printOn (ostream& os);
-
-  GP* NthGP (int n) { return (GP*) GPContainer::Nth (n); }
-
-  virtual int checkForValidCreation (GP& gpo);
-  virtual void create ();
-  virtual GP* createGP (int numOfTrees) { return new GP (numOfTrees); }
-
-  double totalFitness ();
-  long totalLength ();
-  long totalDepth ();
-
-  virtual void tournamentSelection (int *selection, int numToSelect,
-				    int selectWorst, 
-				    GPPopulationRange& range);
-  virtual void probabilisticSelection (int *selection, int numToSelect, 
-				       int selectWorst, 
-				       GPPopulationRange& range);
-  virtual void selectIndices (int *selection, int numToSelect, 
-			      int selectWorst, GPPopulationRange& range);
-  virtual GPContainer* select (int numToSelect, GPPopulationRange& range);
-  virtual GPContainer* selectParents (GPPopulationRange& range);
-  virtual void calculateStatistics ();
-  virtual void evaluate();
-
-  virtual void createGenerationReport (int printLegend, int generation,
-				       ostream& fout, ostream& bout);
-  GPContainer* evolution (GPPopulationRange& range);
-  virtual void generate (GPPopulation& newPop);
-  virtual void demeticMigration ();
-
-  virtual int isA () { return GPID; }
-  virtual char* load (istream& is);
-  virtual void save (ostream& os);
-  void setNodeSets (GPAdfNodeSet& adfNs_);
-  virtual GPObject* createObject() { return new GPPopulation; }
-
-  // Index to the best and worst of a population. Only valid after a
-  // call to calculateStatistics (done by evaluate())
-  int bestOfPopulation, worstOfPopulation;
-
-  GPPopulation& operator = (GPPopulation& gpo) {
-    GPExitSystem ("operator =", "Assignment operator not yet implemented"); 
-    return gpo; }
-
-protected:
-  // We have to save the function and terminal sets here, because we
-  // need them later
-  GPAdfNodeSet* adfNs;
-
-  // These are important variables used for the configuration of the
-  // whole GP system
-  GPVariables GPVar;
-
-  // Average values: some useful statistics. Calculated by
-  // calculateStatistics() (which is called by evaluate())
-  double avgFitness, avgLength, avgDepth;
-
-private:
-  // These variables are needed only for the probablistic selection
-  // method and are calculated anew for every deme or population.  So
-  // they need not to be load/saved.  We save the summed inverse
-  // fitness and the summed fitness of the deme/population in a static
-  // variable and determine whether we have to calculate it again each
-  // call depending on variable firstCallPerDeme (parameter to the
-  // selection function).
-  double invSumFitness;
-  double sumFitness;
-
-  int checkForDiversity (GP& gp);
-};
-
-
-
-#endif
-
diff -urN gpc++0.5.2_oryg/lawn/lawn.cc gpc++0.5.2/lawn/lawn.cc
--- gpc++0.5.2_oryg/lawn/lawn.cc	1997-02-16 13:51:21.000000000 +0100
+++ gpc++0.5.2/lawn/lawn.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,400 +0,0 @@
-
-// lawn.cc
-
-/* ---------------------------------------------------------------
-
-The Lawnmower Problem
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-/*
-
-The definitions of code to map the LawnMower problem developed by John
-Koza into gpc++.
-
-Imagine, if you will, a lawn upon which we have placed a robot who
-wishes to evolve the ability to mow the lawn.  The lawn is a grid
-toriodal world of user defined size (see lawn.h).  Using standard GP
-the robot would have to a lot of moves but with new improved ADF GP
-its a different story ... and ADF GP washes whiter and is lighter than
-ordinary chocolate
-
-The approach I use to solve the problem is a little bit modified:
-
-1. Koza uses an energy variable for whatever reason.  With every move,
-the mower decreases the energy, and if nothing is left, it stops
-moving.  I got bad results if the amount of energy the mower has is
-too low.  I assume Koza used it to reduce calculation power (poor guy
-to have to work with a LISP-machine.  He should have had the GP
-kernel!).
-
-2. Instead, I use a different fitness calculation, and a very good one
-also.  It has this formula:
-
-  area=LawnHorizontal*LawnVertical
-
-  tmp=(area-mower.mown)/area
-
-  stdFitness=tmp + length()*lengthFactor;
-
-area is the area of the lawn.  tmp is a temporary variable with range
-[0..1] and can by used as a fitness measure.  To reduce the length of
-the GP's, a different measure is used: stdFitness is the standardized
-fitness and has a range between 0 and usually 2 (depending on the
-factor the length has).  The calculation time gets better and better
-as the GP trees get smaller.  The lengthFactor determines whether its
-better to decrease tree length or to mow all the grass.
-
-*/
-
-#include <iostream.h>
-#include <fstream.h>
-#include <strstream.h>
-
-#include <stdlib.h>
-#include <new.h>    // For the new-handler
-
-// Include header file of genetic programming system.
-#include "gp.h" 
-#include "gpconfig.h"
-
-#include "lawn.h" 
-
-// Factor to multiply the length with (for the fitness calculation)
-double lengthFactor=1/100.0;
-
-// Define configuration parameters and the neccessary array to
-// read/write the configuration to a file. If you need more variables,
-// just add them below and insert an entry in the configArray.
-GPVariables cfg;
-char *InfoFileName="data";
-struct GPConfigVarInformation configArray[]=
-{
-  {"PopulationSize", DATAINT, &cfg.PopulationSize},
-  {"NumberOfGenerations", DATAINT, &cfg.NumberOfGenerations},
-  {"CreationType", DATAINT, &cfg.CreationType},
-  {"CrossoverProbability", DATADOUBLE, &cfg.CrossoverProbability},
-  {"CreationProbability", DATADOUBLE, &cfg.CreationProbability},
-  {"MaximumDepthForCreation", DATAINT, &cfg.MaximumDepthForCreation},
-  {"MaximumDepthForCrossover", DATAINT, &cfg.MaximumDepthForCrossover},
-  {"SelectionType", DATAINT, &cfg.SelectionType},
-  {"TournamentSize", DATAINT, &cfg.TournamentSize},
-  {"DemeticGrouping", DATAINT, &cfg.DemeticGrouping},
-  {"DemeSize", DATAINT, &cfg.DemeSize},
-  {"DemeticMigProbability", DATADOUBLE, &cfg.DemeticMigProbability},
-  {"SwapMutationProbability", DATADOUBLE, &cfg.SwapMutationProbability},
-  {"ShrinkMutationProbability", DATADOUBLE, &cfg.ShrinkMutationProbability},
-  {"AddBestToNewPopulation", DATAINT, &cfg.AddBestToNewPopulation},
-  {"InfoFileName", DATASTRING, &InfoFileName},
-  {"SteadyState", DATAINT, &cfg.SteadyState},
-  {"LengthFactor", DATADOUBLE, &lengthFactor},
-  {"", DATAINT, NULL}
-};
-
-// The mower on the lawn
-Mower mower;
-
-// A zero vector
-Vector zeroVector (0, 0);
-
-// Used for printing the lawn to a file during evaluation
-int printLawn=0;
-ofstream lawnFile;
-
-
-
-// We overwrite the printOn function to print a random vector not as
-// "RV" but rather the numbers.
-void MyGene::printOn (ostream& os)
-{
-  if (node->value()==RV)
-    // Print out random vector
-    os << randomConstant;
-  else
-    // Use the normal way to print
-    GPGene::printOn (os);
-}
-
-
-
-// We have the freedom to define this function in any way we like.
-// Variable gp is used to be able to evaluate the ADF trees of the GP.
-// arg0 is the argument for ADF1.  It's recursive of course.
-Vector MyGene::evaluate (MyGP& gp, Vector arg0=zeroVector)
-{
-  // Print the lawn?
-//     {
-//       static int print=1;
-//       if (print)
-// 	lawnFile << mower << '\n' << '\n';
-//       print=node->value ()==MOW || node->value ()==FROG;
-//     }
-//   else
-
-  // Stop if all is mown (Speeds things up), but only, if the
-  // printmode is not active.
-  if (!printLawn && mower.mown==LawnHorizontal*LawnVertical)
-    return zeroVector;
-
-  Vector arg;
-  switch (node->value ())
-    {
-
-    case LEFT: 
-      // Turn left and return (0,0) according to Koza
-      mower.left ();
-      return zeroVector;
-      
-    case MOW:
-      // Mow and return (0,0) according to Koza
-      mower.mow ();
-      // Print the lawn after the mow.
-      if (printLawn)
-	lawnFile << mower << '\n' << '\n';
-      return zeroVector;
-      
-    case RV:
-      // Random position. If a value has not yet been assigned, do it
-      // now
-      if (!valueAssigned)
-	{
-	  valueAssigned=1;
-	  randomConstant.x=GPrand () % LawnHorizontal;
-	  randomConstant.y=GPrand () % LawnVertical;
-	}
-      return randomConstant;
-      
-    case ADF0:
-      // No argument for ADF0
-      return gp.NthMyGene (1)->evaluate (gp);
-      
-    case ADF1:
-      // One argument for ADF1
-      return gp.NthMyGene(2)->
-	evaluate (gp, NthMyChild(0)->evaluate (gp));
-      
-    case ARG0:
-      // Argument for ADF1
-      return arg0;
-      
-    case FROG:
-      // Jump to new position and mow
-      arg=NthMyChild(0)->evaluate (gp);
-      mower.frog (arg);
-      // Print the lawn after the jump.
-      if (printLawn)
-	lawnFile << mower << '\n' << '\n';
-      // Identity operator: returns the same
-      return arg;
-      
-    case PROGN:
-      // Evaluate first child
-      NthMyChild(0)->evaluate (gp);
-      
-      // Return evaluation from second child
-      return NthMyChild(1)->evaluate (gp);
-      
-    case VA:
-      // Vector addition
-      return NthMyChild(0)->evaluate (gp)
-	+ NthMyChild(1)->evaluate (gp);
-
-    default: 
-      GPExitSystem ("MyGene::evaluate", "Undefined function value");
-    }
-  
-  // We should never reach this point
-  return zeroVector;
-}
-
-
-
-// Evaluate the fitness of a GP and save it into the class variable
-// fitness.
-void MyGP::evaluate ()
-{
-  // Prepare lawn for mowing
-  mower.reset ();
-  
-  // Print the unmown lawn
-  if (printLawn)
-    lawnFile << mower << '\n' << '\n';
-
-  // Evaluate main tree
-  NthMyGene (0)->evaluate (*this);
-  
-  // Save standardized fitness in object
-  double fitness=(double)(LawnHorizontal*LawnVertical-mower.mown)
-    / (double)(LawnHorizontal*LawnVertical);
-  stdFitness=fitness + (double)length()*lengthFactor;
-
-  // Percentage mown by current GP
-  mown=(1.0-fitness)*100.0;
-}
-
-
-
-// Create function and terminal set
-void createNodeSet (GPAdfNodeSet& adfNs)
-{
-  // Reserve space for the node sets
-  adfNs.reserveSpace (3);
-  
-  // Now define the function and terminal set for each ADF and place
-  // function/terminal sets into overall ADF container
-  GPNodeSet& ns0=*new GPNodeSet (8);
-  GPNodeSet& ns1=*new GPNodeSet (5);
-  GPNodeSet& ns2=*new GPNodeSet (8);
-  adfNs.put (0, ns0);
-  adfNs.put (1, ns1);
-  adfNs.put (2, ns2);
-  
-  // Define functions/terminals and place them into the appropriate
-  // sets. Terminals take two arguments, functions three (the third
-  // parameter is the number of arguments the function has)
-  ns0.putNode (*new GPNode (LEFT, "LEFT"));
-  ns0.putNode (*new GPNode (MOW, "MOW"));
-  ns0.putNode (*new GPNode (RV, "RV"));
-  ns0.putNode (*new GPNode (ADF0, "ADF0"));
-  ns0.putNode (*new GPNode (ADF1, "ADF1", 1));
-  ns0.putNode (*new GPNode (FROG, "FROG", 1));
-  ns0.putNode (*new GPNode (VA, "VA", 2));
-  ns0.putNode (*new GPNode (PROGN, "PROGN", 2));
-  
-  ns1.putNode (*new GPNode (LEFT, "LEFT"));
-  ns1.putNode (*new GPNode (MOW, "MOW"));
-  ns1.putNode (*new GPNode (RV, "RV"));
-  ns1.putNode (*new GPNode (VA, "VA", 2));
-  ns1.putNode (*new GPNode (PROGN, "PROGN", 2));
-  
-  ns2.putNode (*new GPNode (ARG0, "ARG0"));
-  ns2.putNode (*new GPNode (LEFT, "LEFT"));
-  ns2.putNode (*new GPNode (MOW, "MOW"));
-  ns2.putNode (*new GPNode (RV, "RV"));
-  ns2.putNode (*new GPNode (ADF0, "ADF0"));
-  ns2.putNode (*new GPNode (FROG, "FROG", 1));
-  ns2.putNode (*new GPNode (VA, "VA", 2));
-  ns2.putNode (*new GPNode (PROGN, "PROGN", 2));
-}
-
-
-
-void newHandler ()
-{
-  cerr << "\nFatal error: Out of memory." << endl;
-  exit (1);
-}
-
-
-
-int main ()
-{
-  // We set up a new-handler, because we might need a lot of memory,
-  // and we don't know it's there.
-  set_new_handler (newHandler);
-  
-  // Init GP system.
-  GPInit (1, -1);
-  
-  // Read configuration file. The defaults will be overwritten by the
-  // configuration file when read. If it doesn't exist, the defaults
-  // will be written to the file.
-  GPConfiguration config (cout, "lawn.ini", configArray);
-  
-  // Open the main output file for data, lawn and statistics file.
-  // First set up names for data file.  Remember we should delete the
-  // string from the stream, well just a few bytes
-  ostrstream strOutFile, strStatFile, strLawnFile;
-  strOutFile  << InfoFileName << ".dat" << ends;
-  strStatFile << InfoFileName << ".stc" << ends;
-  strLawnFile << InfoFileName << ".lwn" << ends;
-  ofstream fout (strOutFile.str());
-  ofstream bout (strStatFile.str());
-  
-  // Print the configuration
-  fout << cfg << endl;
-  cout << cfg << endl;
-  
-  // Create the adf function/terminal set and print it out.
-  GPAdfNodeSet adfNs;
-  createNodeSet (adfNs);
-  cout << adfNs << endl; 
-  fout << adfNs << endl;  
-  
-  // Create a population with this configuration
-  cout << "Creating initial population ..." << endl;
-  MyPopulation* pop=new MyPopulation (cfg, adfNs);
-  pop->create ();
-  cout << "Ok." << endl;
-  pop->createGenerationReport (1, 0, fout, bout);
-  cout << "Mown: " 
-       << pop->NthMyGP(pop->bestOfPopulation)->mown << "% " 
-       << endl;
-  
-  // This next for statement is the actual genetic programming system
-  // which is in essence just repeated reproduction and crossover loop
-  // through all the generations ...
-  MyPopulation* newPop=NULL;
-  for (int gen=1; gen<=cfg.NumberOfGenerations; gen++)
-    {
-      // Create a new generation from the old one by applying the
-      // genetic operators
-      if (!cfg.SteadyState)
-	newPop=new MyPopulation (cfg, adfNs);
-      pop->generate (*newPop);
-      
-      // Delete the old generation and make the new the old one
-      if (!cfg.SteadyState)
-	{
-	  delete pop;
-	  pop=newPop;
-	}
-
-      // Create a report of this generation and how well it is doing
-      pop->createGenerationReport (0, gen, fout, bout);
-      cout << "Mown: " 
-	   << pop->NthMyGP(pop->bestOfPopulation)->mown << "% " 
-	   << endl;
-    }
-
-  // Print lawn to a text file while evaluating the best one of the
-  // last generation
-  printLawn=1;
-  lawnFile.open (strLawnFile.str());
-  pop->NthMyGP(pop->bestOfPopulation)->evaluate();
-  lawnFile.close ();
-
-  cout << "\nResults are in " 
-       << InfoFileName << ".dat, " 
-       << InfoFileName << ".lwn, " 
-       << InfoFileName << ".stc." << endl;
-  
-  return 0;
-}
diff -urN gpc++0.5.2_oryg/lawn/lawn.h gpc++0.5.2/lawn/lawn.h
--- gpc++0.5.2_oryg/lawn/lawn.h	1997-02-16 13:51:21.000000000 +0100
+++ gpc++0.5.2/lawn/lawn.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,207 +0,0 @@
-
-// lawn.h
-
-/* ---------------------------------------------------------------
-
-The Lawnmower Problem
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money !?) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-#ifndef __LAWN
-#define __LAWN
-
-// The size of the lawn. Feel free to change it. Values of 64x64 are
-// not impossible, but you have to wait a bit for the results...
-#define LawnHorizontal 8
-#define LawnVertical   8
-
-// Identifiers for functions and terminals
-const int LEFT=0;   // Turn left
-const int MOW=1;    // Move forward and mow
-const int RV=2;     // Random vector. Koza used the name RV8
-const int ADF0=3;   // ADF function calls
-const int ADF1=4;
-const int FROG=5;   // Jump and mow there
-const int VA=6;     // Vector addition. Koza used the name VA8 
-const int PROGN=7;  // Execute both arguments, return result from second
-const int ARG0=8;   // Argument for any ADF tree
-
-
-
-// The return types in this problem are all vectors (x,y)
-class Vector 
-{
-public:
-  Vector () : x(0), y(0) {}
-  Vector (int x_, int y_) : x(x_), y(y_) {}
-
-  int x, y;
-};
-
-// Vector addition. The world is a toriodal world, so if the lawn
-// moves out to the right side it comes in left again
-inline Vector operator + (Vector v1, Vector v2)
-{
-  return Vector ((v1.x+v2.x) % LawnHorizontal, 
-		 (v1.y+v2.y) % LawnVertical);
-}
-
-// Print a vector
-inline ostream& operator << (ostream &os, Vector &v)
-{
-  return os << v.x << ',' << v.y;
-}
-
-
-
-// A class for our mower on his lawn
-class Mower
-{
-public:
-  void reset ();
-
-  void left ();
-  void frog (Vector& v);
-  void mow ();
-
-  void mowArea ();
-
-  friend ostream& operator << (ostream &os, Mower &mower);
-
-  // The lawn the mower has to mow
-  unsigned char lawn[LawnHorizontal][LawnVertical];
-
-  // Current position of mower
-  Vector pos;
-
-  // Direction the mower is facing (value 0-3) and how many areas are
-  // already mown
-  int direction, mown;
-};
-
-
-
-// We are now inheriting the classes we want to change.  These are
-// usually the class GPGene, GP and GPPopulation.  Read the
-// documentation for what has to be done when inheriting from the GP
-// classes.  Load and save is not implemented.
-
-class MyGP;
-
-class MyGene : public GPGene
-{
-public:
-  // The constructor
-  MyGene (GPNode& gpo) : GPGene (gpo) { valueAssigned=0; }
-
-  // Copy constructor and the function duplicate used by the container
-  // class
-  MyGene (const MyGene& gpo) : GPGene (gpo) { 
-    valueAssigned=gpo.valueAssigned;
-    randomConstant=gpo.randomConstant; }
-  virtual GPObject& duplicate () { return *(new MyGene(*this)); }
-
-  // We have to overwrite this function to create the objects of our
-  // own class MyGene
-  virtual GPGene* createChild (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  // Just an easy way to access the children of the node
-  MyGene* NthMyChild (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-
-  virtual void printOn (ostream& os);
-
-  Vector evaluate (MyGP& gp, Vector arg0);
-
-  // If this node is a real constant, we need information what constant 
-  // and whether it is already assigned a random value
-  int valueAssigned; 
-  Vector randomConstant;
-};
-
-
-
-class MyGP : public GP 
-{
-public:
-  // The constructor
-  MyGP (int genes) : GP (genes) { mown=0.0; }
-
-  // Copy constructor and the function duplicate used by the container
-  // class
-  MyGP (MyGP& gpo) : GP (gpo) { mown=gpo.mown; }
-  virtual GPObject& duplicate () { return *(new MyGP(*this)); }
-
-  // We have to overwrite this function to create the objects of our
-  // own class MyGene
-  virtual GPGene* createGene (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  // Just an easy way to access the trees of the GP
-  MyGene* NthMyGene (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-
-  virtual void evaluate ();
-
-  // The percentage mown by the GP
-  double mown;
-};
-
-
-
-class MyPopulation : public GPPopulation
-{
-public:
-  // The constructor
-  MyPopulation (GPVariables& GPVar_, GPAdfNodeSet& adfNs_) : 
-    GPPopulation (GPVar_, adfNs_) {}
-
-  // Copy constructor and the function duplicate used by the container
-  // class
-  MyPopulation (MyPopulation& gpo) : GPPopulation(gpo) {}
-  virtual GPObject& duplicate () { return *(new MyPopulation(*this)); }
-
-  // Don't check for ultimate diversity as it takes a long time.
-  // Accept every created GP
-  virtual int checkForValidCreation (GP&) { return 1; }
-
-  // Just an easy way to access the GPs of the population
-  MyGP* NthMyGP (int n) {
-    return (MyGP*) GPContainer::Nth (n); }
-
-  // We have to overwrite this function to create the objects of our
-  // own GP class MyGP
-  virtual GP* createGP (int numOfGenes) { return new MyGP (numOfGenes); }
-};
-
-#endif
-
-
diff -urN gpc++0.5.2_oryg/lawn/lawn.ini gpc++0.5.2/lawn/lawn.ini
--- gpc++0.5.2_oryg/lawn/lawn.ini	1997-02-16 13:51:21.000000000 +0100
+++ gpc++0.5.2/lawn/lawn.ini	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-# Configuration
-PopulationSize                  = 300
-NumberOfGenerations             = 50
-CreationType			= 2
-CreationProbability             = 2.0
-CrossoverProbability            = 98.0
-MaximumDepthForCreation         = 6
-MaximumDepthForCrossover        = 17
-SelectionType                   = 1
-TournamentSize                  = 10
-DemeticGrouping                 = 0
-DemeSize                        = 20
-DemeticMigProbability           = 100.0
-SwapMutationProbability         = 50.0
-ShrinkMutationProbability       = 50.0
-InfoFileName                    = data
-SteadyState			= 1
-LengthFactor			= 0.001
-AddBestToNewPopulation		= 1
diff -urN gpc++0.5.2_oryg/lawn/Makefile gpc++0.5.2/lawn/Makefile
--- gpc++0.5.2_oryg/lawn/Makefile	1997-02-16 13:51:21.000000000 +0100
+++ gpc++0.5.2/lawn/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-
-# Makefile for the lawnmower problem
-
-include		../Makefile.ini
-
-TARGET		= lawn
-
-OBJS		= mower.o lawn.o
-
-CPPFLAGS	= $(OVERALLCPPFLAGS) -I$(GPINCLUDE)
-LDFLAGS		= $(OVERALLLDFLAGS) -L$(GPLIB) -lgp -lm
-
-# Implicit rule how to compile
-.cc.o:
-	$(CCC) $(CPPFLAGS) -c $<
-
-
-
-all: $(TARGET)
-
-clean:
-	rm -f $(OBJS) data.* *~
-
-superclean: clean
-	rm -f $(TARGET)
-
-strip:
-	strip $(OBJS) $(TARGET)
-
-
-
-$(TARGET) : $(OBJS) $(GPLIBFILE)
-	$(CCC) -o $(TARGET) $(OBJS) $(LDFLAGS) $(LIBS)
-
-
-
-# File dependencies
-lawn.o : lawn.cc ../include/gp.h ../include/gpconfig.h lawn.h 
-mower.o : mower.cc ../include/gp.h lawn.h 
-
-
-
diff -urN gpc++0.5.2_oryg/lawn/mower.cc gpc++0.5.2/lawn/mower.cc
--- gpc++0.5.2_oryg/lawn/mower.cc	1997-02-16 13:51:21.000000000 +0100
+++ gpc++0.5.2/lawn/mower.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,140 +0,0 @@
-
-// mower.cc
-
-/* ---------------------------------------------------------------
-
-The Lawnmower Problem
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money !?) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-#include "gp.h"
-#include "lawn.h"
-
-
-
-// Reset lawn and mower.  The lawn grows again, and the mower is
-// placed on the upper left corner facing south.
-void Mower::reset ()
-{
-  for (int x=0; x<LawnHorizontal; x++)
-    for (int y=0; y<LawnVertical; y++)
-      lawn[x][y]=1;
-  mown=0;
-  direction=3;
-  pos=Vector (0, 0);
-}
-
-
-
-// Print a lawn
-ostream& operator << (ostream &os, Mower &mower)
-{
-  for (int y=0; y<LawnVertical; y++)
-    {
-      for (int x=0; x<LawnHorizontal; x++)
-	{
-	  // Mower position?
-	  if (mower.pos.x==x && mower.pos.y==y)
-	    os << 'M';
-	  else
-	    os << (mower.lawn[x][y] ? 'G' : '.');
-	}
-      os << '\n';
-    }
-
-  return os;
-}
-
-
-
-// Move from the current position to one which is the addition of new
-// arg
-void Mower::frog (Vector& v)
-{
-  // New position (vector addition!)
-  pos=pos+v;
-      
-  // Mow the grass in the area in which you have moved....
-  mowArea ();
-}
-
-
-
-// Turn the mower left
-void Mower::left ()
-{
-  direction = (direction + 1) % 4;
-}
-
-
-
-// Move the mower forward and mow that area
-void Mower::mow ()
-{
-  switch (direction)
-    {
-    case 0:
-      // East
-      pos.x = (pos.x + 1 ) % LawnHorizontal;
-      break;
-    case 1:
-      // North
-      pos.y = (pos.y + (LawnVertical-1) ) % LawnVertical;
-      break;
-    case 2:
-      // West
-      pos.x = (pos.x + (LawnHorizontal-1) ) % LawnHorizontal;
-      break;
-    case 3:
-      // South
-      pos.y = (pos.y + 1 ) % LawnVertical;
-      break;
-    default:
-      GPExitSystem ("Mower::mow", "Wrong switch statement");
-    }
-      
-  // mow the grass in the area in which you have moved....
-  mowArea ();
-}
-
-
-
-// Mow the area at current mower position
-void Mower::mowArea ()
-{
-  // Count how many areas are mown already
-  mown+=lawn[pos.x][pos.y];
-  
-  // Mow the grass in the area
-  lawn[pos.x][pos.y]=0;
-}
-
-
-
Pliki gpc++0.5.2_oryg/lib/libgpc++.a i gpc++0.5.2/lib/libgpc++.a rni si
diff -urN gpc++0.5.2_oryg/Makefile gpc++0.5.2/Makefile
--- gpc++0.5.2_oryg/Makefile	1997-02-16 13:51:37.000000000 +0100
+++ gpc++0.5.2/Makefile	2005-06-03 13:54:06.000000000 +0200
@@ -5,39 +5,23 @@
 
 all:
 	cd src; make
-	cd symbreg; make
-	cd lawn; make
-	cd skeleton; make
-	cd ant; make
 
 clean:
 	rm -f *~
 	cd src; make clean
-	cd symbreg; make clean
-	cd lawn; make clean
-	cd skeleton; make clean
-	cd ant; make clean
 
 superclean: 
 	rm -f *~
 	cd src; make superclean
-	cd symbreg; make superclean
-	cd lawn; make superclean
-	cd skeleton; make superclean
-	cd ant; make superclean
 
 # Strip debug information (if there is any). 
 strip:
 	cd src; make strip
-	cd lawn; make strip
-	cd skeleton; make strip
-	cd ant; make strip
-	cd symbreg; make strip
 
 install:
-	$(INSTALL) -d $(INSTALLDIR)/include
-	$(INSTALL) -d $(INSTALLDIR)/lib
-	$(INSTALL) -f $(INSTALLDIR)/lib lib/$(GPLIBFILE)
-	$(INSTALL) -f $(INSTALLDIR)/include include/gp.h
-	$(INSTALL) -f $(INSTALLDIR)/include include/gpconfig.h
+	$(INSTALL) -d $(INSTALLDIR)/gpc++
+	cp $(GPLIBFILE) $(INSTALLDIR)/$(GPINCLUDE)/$(GPFILE)
+	$(INSTALL) -d $(INCLUDEDIR)/gpc++
+	cp $(GPINCLUDE)/gp.h  $(INCLUDEDIR)/$(GPINCLUDE)/gp.h
+	cp $(GPINCLUDE)/gpconfig.h $(INCLUDEDIR)/$(GPINCLUDE)/gpconfig.h
 
diff -urN gpc++0.5.2_oryg/Makefile.ini gpc++0.5.2/Makefile.ini
--- gpc++0.5.2_oryg/Makefile.ini	1997-02-16 13:51:37.000000000 +0100
+++ gpc++0.5.2/Makefile.ini	2005-06-03 13:41:25.000000000 +0200
@@ -1,11 +1,11 @@
 
 # Location of the GP include files and the GP library
-GPINCLUDE	= ../include
-GPLIB		= ../lib
-
+GPINCLUDE	= gpc++
+GPLIB		= lib
+GPFILE		= libgpc++.a
 # Name of GP library.  Change '.a' to '.so' if you want to use dynamic
 # libraries, and change the archive command in src/Makefile as well.
-GPLIBFILE = $(GPLIB)/libgp.a
+GPLIBFILE = $(GPLIB)/$(GPFILE)
 
 # Compiler flags.  Use -O to optimise
 OVERALLCPPFLAGS	= -g
@@ -25,4 +25,5 @@
 
 # Install command and installation directory
 INSTALL		= install
-INSTALLDIR	= /usr/local
+INSTALLDIR	= /usr/lib
+INCLUDEDIR	= /usr/include
diff -urN gpc++0.5.2_oryg/skeleton/Makefile gpc++0.5.2/skeleton/Makefile
--- gpc++0.5.2_oryg/skeleton/Makefile	1997-02-16 13:51:22.000000000 +0100
+++ gpc++0.5.2/skeleton/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-
-# Makefile
-
-include		../Makefile.ini
-
-TARGET		= skeleton
-
-OBJS		= skeleton.o
-
-CPPFLAGS	= $(OVERALLCPPFLAGS) -I$(GPINCLUDE)
-LDFLAGS		= $(OVERALLLDFLAGS) -L$(GPLIB) -lgp -lm
-
-# Implicit rule how to compile
-.cc.o:
-	$(CCC) $(CPPFLAGS) -c $<
-
-
-
-all: $(TARGET) $(OBJS)
-
-$(TARGET) : $(OBJS) $(GPLIBFILE)
-	$(CCC) -o $(TARGET) $(OBJS) $(LDFLAGS) $(LIBS)
-
-
-
-clean:
-	rm -f $(OBJS) data.* *~
-
-superclean: clean
-	rm -f $(TARGET)
-
-strip:
-	strip $(OBJS) $(TARGET)
-
-
-
-# File dependencies
-skeleton.o: skeleton.cc ../include/gpconfig.h ../include/gp.h
-
-
-
diff -urN gpc++0.5.2_oryg/skeleton/skeleton.cc gpc++0.5.2/skeleton/skeleton.cc
--- gpc++0.5.2_oryg/skeleton/skeleton.cc	1997-02-16 13:51:22.000000000 +0100
+++ gpc++0.5.2/skeleton/skeleton.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,331 +0,0 @@
-
-// skeleton.cc
-
-/* -------------------------------------------------------------------
-
-This is the skeleton for a new problem the user wants to tackle using
-genetic programming techniques.
-
-gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-
-Copyright 1993, 1994 Adam P. Fraser and 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
-  or 
-
-(Address may be out of date)
-Adam Fraser, Postgraduate Section, Dept of Elec & Elec Eng,
-Maxwell Building, University Of Salford, Salford, M5 4WT, United Kingdom.
-E-mail: a.fraser@eee.salford.ac.uk
-Tel:    (UK) 061 745 5000 x3633
-Fax:    (UK) 061 745 5999
-
-------------------------------------------------------------------- */
-
-#include <stdlib.h>
-#include <new.h>
-#include <fstream.h>
-#include <strstream.h>
-
-#include "gp.h"
-#include "gpconfig.h"
-
-
-
-// Define configuration parameters and the neccessary array to
-// read/write the configuration to a file.  If you need more
-// variables, just add them below and insert an entry in the
-// configArray.
-GPVariables cfg;
-struct GPConfigVarInformation configArray[]=
-{
-  {"PopulationSize", DATAINT, &cfg.PopulationSize},
-  {"NumberOfGenerations", DATAINT, &cfg.NumberOfGenerations},
-  {"CreationType", DATAINT, &cfg.CreationType},
-  {"CrossoverProbability", DATADOUBLE, &cfg.CrossoverProbability},
-  {"CreationProbability", DATADOUBLE, &cfg.CreationProbability},
-  {"MaximumDepthForCreation", DATAINT, &cfg.MaximumDepthForCreation},
-  {"MaximumDepthForCrossover", DATAINT, &cfg.MaximumDepthForCrossover},
-  {"SelectionType", DATAINT, &cfg.SelectionType},
-  {"TournamentSize", DATAINT, &cfg.TournamentSize},
-  {"DemeticGrouping", DATAINT, &cfg.DemeticGrouping},
-  {"DemeSize", DATAINT, &cfg.DemeSize},
-  {"DemeticMigProbability", DATADOUBLE, &cfg.DemeticMigProbability},
-  {"SwapMutationProbability", DATADOUBLE, &cfg.SwapMutationProbability},
-  {"ShrinkMutationProbability", DATADOUBLE, &cfg.ShrinkMutationProbability},
-  {"AddBestToNewPopulation", DATAINT, &cfg.AddBestToNewPopulation},
-  {"SteadyState", DATAINT, &cfg.SteadyState},
-  {"", DATAINT, NULL}
-};
-
-
-
-// Define function and terminal identifiers
-const int FUNCTION1=0;
-const int FUNCTION2=1;
-const int TERMINAL1=2;
-const int TERMINAL2=3;
-
-
-
-// Define class identifiers
-const int MyGeneID=GPUserID;
-const int MyGPID=GPUserID+1;
-const int MyPopulationID=GPUserID+2;
-
-
-
-// Inherit the three GP classes GPGene, GP and GPPopulation
-class MyGene : public GPGene
-{
-public:
-  // Duplication (mandatory)
-  MyGene (const MyGene& gpo) : GPGene (gpo) { }
-  virtual GPObject& duplicate () { return *(new MyGene(*this)); }
-
-  // Creation of own class objects (mandatory)
-  MyGene (GPNode& gpo) : GPGene (gpo) {}
-  virtual GPGene* createChild (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  // Tree evaluation (not mandatory, but somehow the trees must be
-  // parsed to evaluate the fitness)
-  double evaluate ();
-
-  // Load and save (not mandatory)
-  MyGene () {}
-  virtual int isA () { return MyGeneID; }
-  virtual GPObject* createObject() { return new MyGene; }
-  // virtual char* load (istream& is);
-  // virtual void save (ostream& os);
-
-  // Print (not mandatory) 
-  // virtual void printOn (ostream& os);
-
-  // Access children (not mandatory)
-  MyGene* NthMyChild (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-};
-
-
-
-class MyGP : public GP 
-{
-public:
-  // Duplication (mandatory)
-  MyGP (MyGP& gpo) : GP (gpo) { }
-  virtual GPObject& duplicate () { return *(new MyGP(*this)); }
-
-  // Creation of own class objects (mandatory)
-  MyGP (int genes) : GP (genes) {}
-  virtual GPGene* createGene (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  // Tree evaluation (mandatory)
-  virtual void evaluate ();
-
-  // Print (not mandatory) 
-  // virtual void printOn (ostream& os);
-
-  // Load and save (not mandatory)
-  MyGP () {}
-  virtual int isA () { return MyGPID; }
-  virtual GPObject* createObject() { return new MyGP; }
-  // virtual char* load (istream& is);
-  // virtual void save (ostream& os);
-
-  // Access trees (not mandatory)
-  MyGene* NthMyGene (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-};
-
-
-
-class MyPopulation : public GPPopulation
-{
-public:
-  // Constructor (mandatory)
-  MyPopulation (GPVariables& GPVar_, GPAdfNodeSet& adfNs_) : 
-    GPPopulation (GPVar_, adfNs_) {}
-
-  // Duplication (mandatory)
-  MyPopulation (MyPopulation& gpo) : GPPopulation(gpo) {}
-  virtual GPObject& duplicate () { return *(new MyPopulation(*this)); }
-
-  // Creation of own class objects (mandatory)
-  virtual GP* createGP (int numOfTrees) { return new MyGP (numOfTrees); }
-
-  // Load and save (not mandatory)
-  MyPopulation () {}
-  virtual int isA () { return MyPopulationID; }
-  virtual GPObject* createObject() { return new MyPopulation; }
-  // virtual char* load (istream& is);
-  // virtual void save (ostream& os);
-
-  // Print (not mandatory) 
-  // virtual void printOn (ostream& os);
-
-  // Access genetic programs (not mandatory)
-  MyGP* NthMyGP (int n) {
-    return (MyGP*) GPContainer::Nth (n); }
-};
-
-
-
-// This function evaluates the fitness of a genetic tree.  We have the
-// freedom to define this function in any way we like.  
-double MyGene::evaluate ()
-{
-  double returnValue;
-
-  switch (node->value ())
-    {
-    case FUNCTION1: 
-      returnValue=NthMyChild(0)->evaluate ();
-      break;
-
-    case FUNCTION2: 
-      returnValue=NthMyChild(0)->evaluate ();
-      break;
-      
-    case TERMINAL1:
-      returnValue=0.0;
-      break;
-      
-    case TERMINAL2:
-      returnValue=0.0;
-      break;
-
-    default: 
-      GPExitSystem ("MyGene::evaluate", "Undefined node value");
-    }
-  
-  return returnValue;
-}
-
-
-
-// Evaluate the fitness of a GP and save it into the class variable
-// fitness.
-void MyGP::evaluate ()
-{
-  // Evaluate main tree
-  stdFitness=NthMyGene (0)->evaluate ();
-}
-
-
-
-// Create function and terminal set
-void createNodeSet (GPAdfNodeSet& adfNs)
-{
-  // Reserve space for the node sets
-  adfNs.reserveSpace (1);
-  
-  // Now define the function and terminal set for each ADF and place
-  // function/terminal sets into overall ADF container
-  GPNodeSet& ns=*new GPNodeSet (4);
-  adfNs.put (0, ns);
-  
-  // Define functions/terminals and place them into the appropriate
-  // sets.  Terminals take two arguments, functions three (the third
-  // parameter is the number of arguments the function has)
-  ns.putNode (*new GPNode (FUNCTION1, "FUNCTION1", 1));
-  ns.putNode (*new GPNode (FUNCTION2, "FUNCTION2", 1));
-  ns.putNode (*new GPNode (TERMINAL1, "TERMINAL1"));
-  ns.putNode (*new GPNode (TERMINAL2, "TERMINAL2"));
-}
-
-
-
-void newHandler ()
-{
-  cerr << "\nFatal error: Out of memory." << endl;
-  exit (1);
-}
-
-
-
-int main ()
-{
-  // Set up a new-handler, because we might need a lot of memory, and
-  // we don't know it's there.
-  set_new_handler (newHandler);
-  
-  // Init GP system.
-  GPInit (1, -1);
-  
-  // Read configuration file.
-  GPConfiguration config (cout, "skeleton.ini", configArray);
-  
-  // Print the configuration
-  cout << cfg << endl;
-  
-  // Create the adf function/terminal set and print it out.
-  GPAdfNodeSet adfNs;
-  createNodeSet (adfNs);
-  cout << adfNs << endl; 
-  
-  // Open the main output file for the data and statistics file.
-  // First set up names for data file.  Remember we should delete the
-  // string from the stream, well just a few bytes
-  ostrstream strOutFile, strStatFile;
-  strOutFile  << "data.dat" << ends;
-  strStatFile << "data.stc" << ends;
-  ofstream fout (strOutFile.str());
-  ofstream bout (strStatFile.str());
-  
-  // Create a population with this configuration
-  cout << "Creating initial population ..." << endl;
-  MyPopulation* pop=new MyPopulation (cfg, adfNs);
-  pop->create ();
-  cout << "Ok." << endl;
-  pop->createGenerationReport (1, 0, fout, bout);
-  
-  // This next for statement is the actual genetic programming system
-  // which is in essence just repeated reproduction and crossover loop
-  // through all the generations ...
-  MyPopulation* newPop=NULL;
-  for (int gen=1; gen<=cfg.NumberOfGenerations; gen++)
-    {
-      // Create a new generation from the old one by applying the
-      // genetic operators
-      if (!cfg.SteadyState)
-	newPop=new MyPopulation (cfg, adfNs);
-      pop->generate (*newPop);
-      
-      // Delete the old generation and make the new the old one
-      if (!cfg.SteadyState)
-	{
-	  delete pop;
-	  pop=newPop;
-	}
-
-      // Create a report of this generation and how well it is doing
-      pop->createGenerationReport (0, gen, fout, bout);
-    }
-
-  return 0;
-}
diff -urN gpc++0.5.2_oryg/src/compare.cc gpc++0.5.2/src/compare.cc
--- gpc++0.5.2_oryg/src/compare.cc	1997-02-16 13:51:23.000000000 +0100
+++ gpc++0.5.2/src/compare.cc	2005-06-03 13:35:18.000000000 +0200
@@ -45,7 +45,7 @@
 // Used to guarantee 100% diversity in population in the beginning of
 // a run
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/compare.o i gpc++0.5.2/src/compare.o rni si
diff -urN gpc++0.5.2_oryg/src/config.cc gpc++0.5.2/src/config.cc
--- gpc++0.5.2_oryg/src/config.cc	1997-02-16 13:51:23.000000000 +0100
+++ gpc++0.5.2/src/config.cc	2005-06-03 13:35:32.000000000 +0200
@@ -84,14 +84,14 @@
 Thomas Weinbrenner 1996, 1997
 
 */
-
-#include <fstream.h>
-#include <iomanip.h>
+using namespace std;
+#include <fstream>
+#include <iomanip>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 
-#include "gpconfig.h"
+#include "../gpc++/gpconfig.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/config.o i gpc++0.5.2/src/config.o rni si
diff -urN gpc++0.5.2_oryg/src/contain.cc gpc++0.5.2/src/contain.cc
--- gpc++0.5.2_oryg/src/contain.cc	1997-02-16 13:51:23.000000000 +0100
+++ gpc++0.5.2/src/contain.cc	2005-06-03 13:35:39.000000000 +0200
@@ -48,7 +48,7 @@
 
 #include <stdlib.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/contain.o i gpc++0.5.2/src/contain.o rni si
diff -urN gpc++0.5.2_oryg/src/create.cc gpc++0.5.2/src/create.cc
--- gpc++0.5.2_oryg/src/create.cc	1997-02-16 13:51:23.000000000 +0100
+++ gpc++0.5.2/src/create.cc	2005-06-03 13:35:43.000000000 +0200
@@ -42,7 +42,7 @@
 
 ------------------------------------------------------------------- */
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/create.o i gpc++0.5.2/src/create.o rni si
diff -urN gpc++0.5.2_oryg/src/cross.cc gpc++0.5.2/src/cross.cc
--- gpc++0.5.2_oryg/src/cross.cc	1997-02-16 13:51:24.000000000 +0100
+++ gpc++0.5.2/src/cross.cc	2005-06-03 13:35:48.000000000 +0200
@@ -46,7 +46,7 @@
 
 #include <stdlib.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/cross.o i gpc++0.5.2/src/cross.o rni si
diff -urN gpc++0.5.2_oryg/src/eval.cc gpc++0.5.2/src/eval.cc
--- gpc++0.5.2_oryg/src/eval.cc	1997-02-16 13:51:24.000000000 +0100
+++ gpc++0.5.2/src/eval.cc	2005-06-03 13:35:53.000000000 +0200
@@ -42,7 +42,7 @@
 
 ------------------------------------------------------------------- */
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/eval.o i gpc++0.5.2/src/eval.o rni si
diff -urN gpc++0.5.2_oryg/src/gene.cc gpc++0.5.2/src/gene.cc
--- gpc++0.5.2_oryg/src/gene.cc	1997-02-16 13:51:24.000000000 +0100
+++ gpc++0.5.2/src/gene.cc	2005-06-03 13:35:57.000000000 +0200
@@ -50,7 +50,7 @@
 
 #include <stdlib.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/gene.o i gpc++0.5.2/src/gene.o rni si
diff -urN gpc++0.5.2_oryg/src/generate.cc gpc++0.5.2/src/generate.cc
--- gpc++0.5.2_oryg/src/generate.cc	1997-02-16 13:51:24.000000000 +0100
+++ gpc++0.5.2/src/generate.cc	2005-06-03 13:36:01.000000000 +0200
@@ -46,7 +46,7 @@
 
 #include <stdlib.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/generate.o i gpc++0.5.2/src/generate.o rni si
diff -urN gpc++0.5.2_oryg/src/gp.cc gpc++0.5.2/src/gp.cc
--- gpc++0.5.2_oryg/src/gp.cc	1997-02-16 13:51:24.000000000 +0100
+++ gpc++0.5.2/src/gp.cc	2005-06-03 13:36:06.000000000 +0200
@@ -46,7 +46,7 @@
 
 
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/gp.o i gpc++0.5.2/src/gp.o rni si
diff -urN gpc++0.5.2_oryg/src/gprand.cc gpc++0.5.2/src/gprand.cc
--- gpc++0.5.2_oryg/src/gprand.cc	1997-02-16 13:51:25.000000000 +0100
+++ gpc++0.5.2/src/gprand.cc	2005-06-03 13:36:11.000000000 +0200
@@ -46,7 +46,7 @@
 // Teukolsky and Vetterling.  This is a great book indeed, and you
 // should have at least a look at it!
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/gprand.o i gpc++0.5.2/src/gprand.o rni si
diff -urN gpc++0.5.2_oryg/src/gpv.cc gpc++0.5.2/src/gpv.cc
--- gpc++0.5.2_oryg/src/gpv.cc	1997-02-16 13:51:25.000000000 +0100
+++ gpc++0.5.2/src/gpv.cc	2005-06-03 13:36:16.000000000 +0200
@@ -48,9 +48,9 @@
 
 
 #include <stdlib.h>
-#include <fstream.h>
+#include <fstream>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/gpv.o i gpc++0.5.2/src/gpv.o rni si
diff -urN gpc++0.5.2_oryg/src/loadsave.cc gpc++0.5.2/src/loadsave.cc
--- gpc++0.5.2_oryg/src/loadsave.cc	1997-02-16 13:51:25.000000000 +0100
+++ gpc++0.5.2/src/loadsave.cc	2005-06-03 13:36:20.000000000 +0200
@@ -44,7 +44,7 @@
 
 #include <stdio.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/loadsave.o i gpc++0.5.2/src/loadsave.o rni si
diff -urN gpc++0.5.2_oryg/src/Makefile gpc++0.5.2/src/Makefile
--- gpc++0.5.2_oryg/src/Makefile	1997-02-16 13:51:26.000000000 +0100
+++ gpc++0.5.2/src/Makefile	2005-06-03 13:53:05.000000000 +0200
@@ -38,8 +38,8 @@
 # Create the GP library. Use either ld (for dynamic libraries) or ar
 # and ranlib.
 $(TARGET) : $(OBJS) 
-	$(AR) -r $(TARGET) $(OBJS)
-	$(RANLIB) $(TARGET)
+	$(AR) -r ../lib/$(GPFILE) *.o
+	$(RANLIB) ../lib/$(GPFILE)
 #	$(LD) -r -o $(TARGET) $(OBJS)
 
 clean:
@@ -55,20 +55,20 @@
 
 
 # File dependencies
-compare.o: compare.cc ../include/gp.h
-config.o: config.cc ../include/gpconfig.h
-contain.o: contain.cc ../include/gp.h
-create.o: create.cc ../include/gp.h
-cross.o: cross.cc ../include/gp.h
-eval.o: eval.cc ../include/gp.h
-gene.o: gene.cc ../include/gp.h
-generate.o: generate.cc ../include/gp.h
-gp.o: gp.cc ../include/gp.h
-gprand.o: gprand.cc ../include/gp.h
-gpv.o: gpv.cc ../include/gp.h
-loadsave.o: loadsave.cc ../include/gp.h
-misc.o: misc.cc ../include/gp.h
-mutate.o: mutate.cc ../include/gp.h
-node.o: node.cc ../include/gp.h
-pop.o: pop.cc ../include/gp.h
-select.o: select.cc ../include/gp.h
+compare.o: compare.cc ../gpc++/gp.h
+config.o: config.cc ../gpc++/gpconfig.h
+contain.o: contain.cc ../gpc++/gp.h
+create.o: create.cc ../gpc++/gp.h
+cross.o: cross.cc ../gpc++/gp.h
+eval.o: eval.cc ../gpc++/gp.h
+gene.o: gene.cc ../gpc++/gp.h
+generate.o: generate.cc ../gpc++/gp.h
+gp.o: gp.cc ../gpc++/gp.h
+gprand.o: gprand.cc ../gpc++/gp.h
+gpv.o: gpv.cc ../gpc++/gp.h
+loadsave.o: loadsave.cc ../gpc++/gp.h
+misc.o: misc.cc ../gpc++/gp.h
+mutate.o: mutate.cc ../gpc++/gp.h
+node.o: node.cc ../gpc++/gp.h
+pop.o: pop.cc ../gpc++/gp.h
+select.o: select.cc ../gpc++/gp.h
diff -urN gpc++0.5.2_oryg/src/misc.cc gpc++0.5.2/src/misc.cc
--- gpc++0.5.2_oryg/src/misc.cc	1997-02-16 13:51:25.000000000 +0100
+++ gpc++0.5.2/src/misc.cc	2005-06-03 13:37:42.000000000 +0200
@@ -44,11 +44,11 @@
 
 // Simply an exit system, which outputs some error
 
-#include <iostream.h>
+#include <iostream>
 #include <time.h>
 #include <stdlib.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/misc.o i gpc++0.5.2/src/misc.o rni si
diff -urN gpc++0.5.2_oryg/src/mutate.cc gpc++0.5.2/src/mutate.cc
--- gpc++0.5.2_oryg/src/mutate.cc	1997-02-16 13:51:25.000000000 +0100
+++ gpc++0.5.2/src/mutate.cc	2005-06-03 13:36:33.000000000 +0200
@@ -44,7 +44,7 @@
 
 #include <stdio.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/mutate.o i gpc++0.5.2/src/mutate.o rni si
diff -urN gpc++0.5.2_oryg/src/node.cc gpc++0.5.2/src/node.cc
--- gpc++0.5.2_oryg/src/node.cc	1997-02-16 13:51:26.000000000 +0100
+++ gpc++0.5.2/src/node.cc	2005-06-03 13:36:40.000000000 +0200
@@ -54,7 +54,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/node.o i gpc++0.5.2/src/node.o rni si
diff -urN gpc++0.5.2_oryg/src/pop.cc gpc++0.5.2/src/pop.cc
--- gpc++0.5.2_oryg/src/pop.cc	1997-02-16 13:51:25.000000000 +0100
+++ gpc++0.5.2/src/pop.cc	2005-06-03 13:36:51.000000000 +0200
@@ -45,10 +45,10 @@
 // The Population class has most of the genetic programming operator
 // applied to it. 
 
-#include <iomanip.h>
+#include <iomanip>
 #include <stdio.h>
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/pop.o i gpc++0.5.2/src/pop.o rni si
diff -urN gpc++0.5.2_oryg/src/select.cc gpc++0.5.2/src/select.cc
--- gpc++0.5.2_oryg/src/select.cc	1997-02-16 13:51:26.000000000 +0100
+++ gpc++0.5.2/src/select.cc	2005-06-03 13:37:00.000000000 +0200
@@ -46,7 +46,7 @@
 
 
 
-#include "gp.h"
+#include "../gpc++/gp.h"
 
 
 
Pliki gpc++0.5.2_oryg/src/select.o i gpc++0.5.2/src/select.o rni si
diff -urN gpc++0.5.2_oryg/symbreg/Makefile gpc++0.5.2/symbreg/Makefile
--- gpc++0.5.2_oryg/symbreg/Makefile	1997-02-16 13:51:27.000000000 +0100
+++ gpc++0.5.2/symbreg/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-
-# Makefile for the symbolic regression problem
-
-include		../Makefile.ini
-
-TARGET		= sym
-
-OBJS		= symbreg.o
-
-CPPFLAGS	= $(OVERALLCPPFLAGS) -I$(GPINCLUDE)
-LDFLAGS		= $(OVERALLLDFLAGS) -L$(GPLIB) -lgp -lm 
-
-# Implicit rule how to compile
-.cc.o:
-	$(CCC) $(CPPFLAGS) -c $<
-
-
-
-all: $(TARGET)
-
-clean:
-	rm -f $(OBJS) result.* *~
-
-superclean: clean
-	rm -f $(TARGET)
-
-strip:
-	strip $(OBJS) $(TARGET)
-
-
-
-$(TARGET) : $(OBJS) $(GPLIBFILE)
-	$(CCC) -o $(TARGET) $(OBJS) $(LDFLAGS) $(LIBS)
-
-
-
-# File dependencies
-symbreg.o: symbreg.cc ../include/gpconfig.h ../include/gp.h
-
-
-
diff -urN gpc++0.5.2_oryg/symbreg/symbreg.cc gpc++0.5.2/symbreg/symbreg.cc
--- gpc++0.5.2_oryg/symbreg/symbreg.cc	1997-02-16 13:51:27.000000000 +0100
+++ gpc++0.5.2/symbreg/symbreg.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,584 +0,0 @@
-
-// symbreg.cc
-
-/* ---------------------------------------------------------------
-
-Symbolic Regression
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money !?) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-#include <iostream.h>
-#include <fstream.h>
-#include <strstream.h>
-
-#include <stdlib.h>
-#include <new.h>    // For the new-handler
-#include <math.h>   // fabs()
-#include <string.h>
-
-// Include header file of genetic programming system.
-#include "gp.h" 
-#include "gpconfig.h"
-
-#include "symbreg.h"
-
-// Define the function to be symbolically regressed and set up
-// question and answer array with some points for the function
-#define EQUATION(x)  (x*x*x*x + x*x*x + x*x + x)
-#define DATAPOINTS 10
-double ques[DATAPOINTS];
-double answ[DATAPOINTS];
-
-// The TeX-file
-ofstream tout;
-int printTexStyle=0;
-
-// Define configuration parameters and the neccessary array to
-// read/write the configuration to a file. If you need more variables,
-// just add them below and insert an entry in the configArray.
-GPVariables cfg;
-char *InfoFileName="data";
-struct GPConfigVarInformation configArray[]=
-{
-  {"PopulationSize", DATAINT, &cfg.PopulationSize},
-  {"NumberOfGenerations", DATAINT, &cfg.NumberOfGenerations},
-  {"CreationType", DATAINT, &cfg.CreationType},
-  {"CrossoverProbability", DATADOUBLE, &cfg.CrossoverProbability},
-  {"CreationProbability", DATADOUBLE, &cfg.CreationProbability},
-  {"MaximumDepthForCreation", DATAINT, &cfg.MaximumDepthForCreation},
-  {"MaximumDepthForCrossover", DATAINT, &cfg.MaximumDepthForCrossover},
-  {"SelectionType", DATAINT, &cfg.SelectionType},
-  {"TournamentSize", DATAINT, &cfg.TournamentSize},
-  {"DemeticGrouping", DATAINT, &cfg.DemeticGrouping},
-  {"DemeSize", DATAINT, &cfg.DemeSize},
-  {"DemeticMigProbability", DATADOUBLE, &cfg.DemeticMigProbability},
-  {"SwapMutationProbability", DATADOUBLE, &cfg.SwapMutationProbability},
-  {"ShrinkMutationProbability", DATADOUBLE, &cfg.ShrinkMutationProbability},
-  {"SteadyState", DATAINT, &cfg.SteadyState},
-  {"AddBestToNewPopulation", DATAINT, &cfg.AddBestToNewPopulation},
-  {"InfoFileName", DATASTRING, &InfoFileName},
-  {"", DATAINT, NULL}
-};
-
-
-
-// Print out a gene in typical math style. Don't be confused, I don't
-// make a difference whether this gene is the main program or an ADF,
-// I assume the internal structure is correct.
-void MyGene::printMathStyle (ostream& os, int lastPrecedence)
-{
-  int precedence;
-
-  // Function or terminal?
-  if (isFunction ())
-    {
-      // Determine operator priority
-      switch (node->value ())
-	{
-	case '*': 
-	case '%': 
-	  precedence=1;
-	  break;
-	case '+': 
-	case '-': 
-	  precedence=0;
-	  break;
-	case 'A': 
-	  precedence=2;
-	  break;
-	default:
-	  GPExitSystem ("MyGene::printMathStyle", 
-			"Undefined function value");
-	}
-
-      // Do we need brackets?
-      if (lastPrecedence>precedence)
-	os << "(";
-
-      // Print out the operator and the parameters 
-      switch (node->value ())
-	{
-	case '*': 
-	  NthMyChild(0)->printMathStyle (os, precedence);
-	  os << "*";
-	  NthMyChild(1)->printMathStyle (os, precedence);
-	  break;
-	case '+': 
-	  NthMyChild(0)->printMathStyle (os, precedence);
-	  os << "+";
-	  NthMyChild(1)->printMathStyle (os, precedence);
-	  break;
-	case '-': 
-	  NthMyChild(0)->printMathStyle (os, precedence);
-	  os << "-";
-	  NthMyChild(1)->printMathStyle (os, precedence);
-	  break;
-	case '%': 
-	  NthMyChild(0)->printMathStyle (os, precedence);
-	  os << "%";
-	  NthMyChild(1)->printMathStyle (os, precedence);
-	  break;
-	case 'A': 
-	  // This is the ADF0-function. We put the parameters in
-	  // brackets and start again with precedence 0.
-	  os << "ADF0 (";
-	  NthMyChild(0)->printMathStyle (os, 0);
-	  os << ",";
-	  NthMyChild(1)->printMathStyle (os, 0);
-	  os << ")";
-	  break;
-	default: 
-	  GPExitSystem ("MyGene::printMathStyle", 
-			"Undefined function value");
-	}
-
-      // Do we need brackets?
-      if (lastPrecedence>precedence)
-	os << ")";
-    }
-
-  // Print the terminal
-  if (isTerminal ())
-    os << *node;
-}
-
-
-
-// Print out a gene in LaTeX-style. Don't be confused, I don't make a
-// difference whether this gene is the main program or an ADF, I
-// assume the internal structure is correct.
-void MyGene::printTeXStyle (ostream& os, int lastPrecedence)
-{
-  int precedence=0;
-
-  // Function or terminal?
-  if (isFunction ())
-    {
-      // Determine operator priority
-      switch (node->value())
-	{
-	case '*': 
-	case '%': 
-	  precedence=2;
-	  break;
-	case '+': 
-	case '-': 
-	  precedence=1;
-	  break;
-	case 'A': 
-	  precedence=3;
-	  break;
-	default:
-	  GPExitSystem ("MyGene::printTeXStyle", 
-			"Undefined function value");
-	}
-
-      // Do we need brackets?
-      if (lastPrecedence>precedence)
-	os << "\\left(";
-
-      // Print out the operator and the parameters 
-      switch (node->value())
-	{
-	case '*': 
-	  NthMyChild(0)->printTeXStyle (os, precedence);
-	  os << " ";
-	  NthMyChild(1)->printTeXStyle (os, precedence);
-	  break;
-	case '+': 
-	  NthMyChild(0)->printTeXStyle (os, precedence);
-	  os << "+";
-	  NthMyChild(1)->printTeXStyle (os, precedence);
-	  break;
-	case '-': 
-	  NthMyChild(0)->printTeXStyle (os, precedence);
-	  os << "-";
-	  NthMyChild(1)->printTeXStyle (os, precedence);
-	  break;
-	case '%': 
-	  // As we use \frac, we start again with precedence 0
-	  os << "\\frac{";
-	  NthMyChild(0)->printTeXStyle (os, 0);
-	  os << "}{";
-	  NthMyChild(1)->printTeXStyle (os, 0);
-	  os << "}";
-	  break;
-	case 'A': 
-	  // This is the ADF0-function. We put the parameters in
-	  // brackets and start again with precedence 0.
-	  os << "f_2(";
-	  NthMyChild(0)->printTeXStyle (os, 0);
-	  os << ",";
-	  NthMyChild(1)->printTeXStyle (os, 0);
-	  os << ")";
-	  break;
-	default: 
-	  GPExitSystem ("MyGene::printTeXStyle", 
-			"Undefined function value");
-	}
-
-      // Do we need brackets?
-      if (lastPrecedence>precedence)
-	os << "\\right)";
-    }
-
-  // We can't let the terminal print itself, because we want to modify
-  // it a little bit
-  if (isTerminal ())
-    switch (node->value ())
-      {
-      case 'X': 
-	os << "x";
-	break;
-      case 1:
-	os << "x_1";
-	break;
-      case 2:
-	os << "x_2";
-	break;
-      default: 
-	GPExitSystem ("MyGene::printTeXStyle", 
-		      "Undefined terminal value");
-      }
-}
-
-
-
-// Print a Gene.
-void MyGene::printOn (ostream& os)
-{
-  if (printTexStyle)
-    printTeXStyle (os);
-  else
-    printMathStyle (os);
-}
-
-
-
-// Print a GP. If we want a LaTeX-output, we must provide for the
-// equation environment, otherwise we simply call the print function
-// of our base class.
-void MyGP::printOn (ostream& os)
-{
-  // If we use LaTeX-style, we provide here for the right equation
-  // overhead used for LaTeX. 
-  if (printTexStyle)
-    {
-      tout << "\\begin{eqnarray}" << endl;
-
-      // Print all ADF's, if any
-      GPGene* current;
-      for (int n=0; n<containerSize(); n++)
-	{
-	  if (n!=0)
-	    os << "\\\\" << endl;
-	  os << "f_" << n+1 << " & = & ";
-	  if ((current=NthGene (n)))
-	    os << *current;
-	  else
-	    os << " NONE";
-	  os << "\\nonumber ";
-	}
-      tout << endl << "\\end{eqnarray}" << endl << endl;
-      
-    }
-  else
-    // Just call the print function of our base class to do the
-    // standard job.
-    GP::printOn (os);
-}
-
-
-
-// This function is the divide with closure. Basically if you divide
-// anything by zero you get an error so we have to stop this
-// process. We check for a very small denominator and return a very
-// high value.
-inline double divide (double x, double y)
-{
-  if (fabs (y)<1e-6)
-    {
-      if (x*y<0.0) 
-	return -1e6;
-      else
-	return 1e6;
-    }
-  else
-    return x/y;
-}
-
-
-
-// We have the freedom to define this function in any way we like. In
-// this case, it takes the parameter x that represents the terminal X,
-// and returns the value of the expression. It's recursive of course.
-double MyGene::evaluate (double x, MyGP& gp, double arg0, double arg1)
-{
-  double ret, a0, a1;
-
-  if (isFunction ())
-    switch (node->value ())
-      {
-      case '*': 
-	ret=NthMyChild(0)->evaluate (x, gp, arg0, arg1)
-	  * NthMyChild(1)->evaluate (x, gp, arg0, arg1);
-	break;
-      case '+': 
-	ret=NthMyChild(0)->evaluate (x, gp, arg0, arg1)
-	  + NthMyChild(1)->evaluate (x, gp, arg0, arg1);
-	break;
-      case '-': 
-	ret=NthMyChild(0)->evaluate (x, gp, arg0, arg1)
-	  - NthMyChild(1)->evaluate (x, gp, arg0, arg1);
-	break;
-      case '%': 
-	// We use the function divide rather than "/" to ensure the
-	// closure property
-	ret=divide (NthMyChild(0)->evaluate (x, gp, arg0, arg1), 
-		    NthMyChild(1)->evaluate (x, gp, arg0, arg1));
-	break;
-      case 'A': 
-	// This is the ADF0 function call.  We have access to that
-	// subtree, as the GP gave us a reference to itself as
-	// parameter.  We first evaluate the subtrees, and then call
-	// the adf with the parameters
-	a0=NthMyChild(0)->evaluate (x, gp, arg0, arg1);
-	a1=NthMyChild(1)->evaluate (x, gp, arg0, arg1);
-	ret=gp.NthMyGene(1)->evaluate (x, gp, a0, a1);
-	break;
-      default: 
-	GPExitSystem ("MyGene::evaluate", "Undefined function value");
-      }
-  if (isTerminal ())
-    switch (node->value ())
-      {
-      case 'X': 
-	ret=x;
-	break;
-      case 1:
-	ret=arg0;
-	break;
-      case 2:
-	ret=arg1;
-	break;
-      default: 
-	GPExitSystem ("MyGene::evaluate", "Undefined terminal value");
-      }
-
-  // Restrict the return value (it may become really large, especially
-  // for large trees)
-  const double maxValue=1e6;
-  if (ret>maxValue)
-    return maxValue;
-  if (ret<-maxValue)
-    return -maxValue;
-
-  return ret;
-}
-
-
-
-// Evaluate the fitness of a GP and save it into the GP class variable
-// stdFitness.
-void MyGP::evaluate ()
-{
-  double rawfitness=0.0, diff=0.0;
-
-  // The evaluation function checks with some values of the
-  // mathematical function
-  for (int i=0; i<DATAPOINTS; i++)
-    {
-      // Calculate genetic programs answer.  ques[i] is the current x
-      // value of the function.
-      double result=NthMyGene(0)->evaluate (ques[i], *this, 0, 0);
-
-      // Calculate square error between the genetic program and the
-      // actual answer.
-      diff=pow (answ[i]-result, 2);
-
-      // Add this difference to total rawfitness
-      rawfitness+=diff;
-    }
-  rawfitness=sqrt (rawfitness);
-
-  // We want a short solution and put the total GP length to the
-  // fitness.  As we know that the best solution has the length 12, we
-  // create such a formula that the fitness will be 1.0 in this case.
-  // This standardized fitness is saved in the GP object.
-  stdFitness=rawfitness+(double)length ()/12.0;
-}
-
-
-
-// Create function and terminal set
-void createNodeSet (GPAdfNodeSet& adfNs)
-{
-  // Reserve space for the node sets
-  adfNs.reserveSpace (2);
-
-  // Now define the function and terminal set for each ADF and place
-  // function/terminal sets into overall ADF container
-  GPNodeSet& ns0=*new GPNodeSet (6);
-  GPNodeSet& ns1=*new GPNodeSet (4);
-  adfNs.put (0, ns0);
-  adfNs.put (1, ns1);
-
-  // Define functions/terminals and place them into the appropriate
-  // sets. Terminals take two arguments, functions three (the third
-  // parameter is the number of arguments the function has)
-  ns0.putNode (*new GPNode ('+', "+", 2));
-  ns0.putNode (*new GPNode ('-', "-", 2));
-  ns0.putNode (*new GPNode ('*', "*", 2));
-  ns0.putNode (*new GPNode ('%', "%", 2));
-  ns0.putNode (*new GPNode ('A', "ADF0", 2));
-  ns0.putNode (*new GPNode ('X', "x"));
-
-  ns1.putNode (*new GPNode ('+', "+", 2));
-  ns1.putNode (*new GPNode ('*', "*", 2));
-  ns1.putNode (*new GPNode (1, "x1"));
-  ns1.putNode (*new GPNode (2, "x2"));
-}
-
-
-
-void newHandler ()
-{
-  cerr << "\nFatal error: Out of memory." << endl;
-  exit (1);
-}
-
-
-
-int main ()
-{
-  // We set up a new-handler, because we might need a lot of memory,
-  // and we don't know it's there.
-  set_new_handler (newHandler);
-
-  // Set up the array with data points. This is for the evaluation
-  // process.
-  for (int i=0; i<DATAPOINTS; i++)
-    {
-      ques[i]=i;
-      answ[i]=EQUATION(ques[i]);
-    }
-
-  // Init GP system.
-  GPInit (1, -1);
-
-  // Declare the GP Variables, set defaults and read configuration
-  // file.  The defaults will be overwritten by the configuration file
-  // when read.  If it doesn't exist, the defaults will be written to
-  // the file.
-  GPConfiguration config (cout, "symbreg.ini", configArray);
-
-  // Open the main output file for data and statistics file. First set
-  // up names for data file. We use also a TeX-file where the
-  // equations are written to in TeX-style. Very nice to look at!
-  // Remember we should delete the string from the stream, well just a
-  // few bytes
-  ostrstream strOutFile, strStatFile, strTeXFile;
-  strOutFile  << InfoFileName << ".dat" << ends;
-  strStatFile << InfoFileName << ".stc" << ends;
-  strTeXFile  << InfoFileName << ".tex" << ends;
-  ofstream fout (strOutFile.str());
-  ofstream bout (strStatFile.str());
-  tout.open (strTeXFile.str(), ios::out);
-  tout << endl
-       << "\\documentstyle[a4]{article}" << endl
-       << "\\begin{document}" << endl;
-  
-  // Print the configuration to the files just opened
-  fout << cfg << endl;
-  cout << cfg << endl;
-  tout << "\\begin{verbatim}\n" << cfg << "\\end{verbatim}\n" << endl;
-  
-  // Create the adf function/terminal set and print it out.
-  GPAdfNodeSet adfNs;
-  createNodeSet (adfNs);
-  cout << adfNs << endl; 
-  fout << adfNs << endl;  
-
-  // Create a population with this configuration
-  cout << "Creating initial population ..." << endl;
-  MyPopulation* pop=new MyPopulation (cfg, adfNs);
-  pop->create ();
-  cout << "Ok." << endl;
-  pop->createGenerationReport (1, 0, fout, bout);
-
-  // Print the best of generation to the LaTeX-file.
-  printTexStyle=1;
-  tout << *pop->NthGP (pop->bestOfPopulation);
-  printTexStyle=0;
-
-  // This next for statement is the actual genetic programming system
-  // which is in essence just repeated reproduction and crossover loop
-  // through all the generations .....
-  MyPopulation* newPop=NULL;
-  for (int gen=1; gen<=cfg.NumberOfGenerations; gen++)
-    {
-      // Create a new generation from the old one by applying the
-      // genetic operators
-      if (!cfg.SteadyState)
-	newPop=new MyPopulation (cfg, adfNs);
-      pop->generate (*newPop);
-      
-      // Delete the old generation and make the new the old one
-      if (!cfg.SteadyState)
-	{
-	  delete pop;
-	  pop=newPop;
-	}
-
-      // Print the best of generation to the LaTeX-file.
-      printTexStyle=1;
-      tout << "Generation " << gen << ", fitness " 
-	   << pop->NthGP (pop->bestOfPopulation)->getFitness()
-	   << endl;
-      tout << *pop->NthGP (pop->bestOfPopulation);
-      printTexStyle=0;
-
-      // Create a report of this generation and how well it is doing
-      pop->createGenerationReport (0, gen, fout, bout);
-    }
-
-  // TeX-file: end of document
-  tout << endl
-       << "\\end{document}"
-       << endl;
-  tout.close ();
-
-  cout << "\nResults are in " 
-       << InfoFileName << ".dat," 
-       << InfoFileName << ".tex,"
-       << InfoFileName << ".stc." << endl;
-
-  return 0;
-}
diff -urN gpc++0.5.2_oryg/symbreg/symbreg.h gpc++0.5.2/symbreg/symbreg.h
--- gpc++0.5.2_oryg/symbreg/symbreg.h	1997-02-16 13:51:27.000000000 +0100
+++ gpc++0.5.2/symbreg/symbreg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,102 +0,0 @@
-
-// symbreg.h
-
-/* ---------------------------------------------------------------
-
-Symbolic Regression
-
-An example for how to use gpc++ - The Genetic Programming Kernel
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 1, or (at your option)
-any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-Copyright 1996, 1997 Thomas Weinbrenner
-
-For comments, improvements, additions (or even money !?) contact:
-
-Thomas Weinbrenner
-Grauensteinstr. 26
-35789 Laimbach
-Germany
-E-mail: thomasw@emk.e-technik.th-darmstadt.de
-WWW:    http://www.emk.e-technik.th-darmstadt/~thomasw
-
---------------------------------------------------------------- */
-
-// We are now inheriting the classes we want to change. These are the
-// three classes GPGene, GP and GPPopulation.  Read the documentation
-// for what has to be done here.  Remember it makes not a lot of sense
-// to implement Load/Save here, otherwise we should definitely have to
-// provide for the isA(), load(), save() and createObject() functions.
-
-class MyGP;
-
-class MyGene : public GPGene
-{
-public:
-  MyGene (GPNode& gpo) : GPGene (gpo) {}
-
-  MyGene (const MyGene& gpo) : GPGene (gpo) { }
-  virtual GPObject& duplicate () { return *(new MyGene(*this)); }
-  virtual GPGene* createChild (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  virtual void printOn (ostream& os);
-  void printMathStyle (ostream& os, int lastPrecedence=0);
-  void printTeXStyle (ostream& os, int lastPrecedence=0);
-
-  MyGene* NthMyChild (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-
-  double evaluate (double x, MyGP& gp, double arg0, double arg1);
-};
-
-
-
-class MyGP : public GP 
-{
-public:
-  MyGP (int genes) : GP (genes) {}
-
-  MyGP (MyGP& gpo) : GP (gpo) { }
-  virtual GPObject& duplicate () { return *(new MyGP(*this)); }
-  virtual GPGene* createGene (GPNode& gpo) {
-    return new MyGene (gpo); }
-
-  virtual void printOn (ostream& os);
-
-  MyGene* NthMyGene (int n) {
-    return (MyGene*) GPContainer::Nth (n); }
-  virtual void evaluate ();
-};
-
-
-
-class MyPopulation : public GPPopulation
-{
-public:
-  MyPopulation (GPVariables& GPVar_, GPAdfNodeSet& adfNs_) : 
-    GPPopulation (GPVar_, adfNs_) {}
-
-  MyPopulation (MyPopulation& gpo) : GPPopulation(gpo) {}
-  virtual GPObject& duplicate () { return *(new MyPopulation(*this)); }
-
-  // Don't check for ultimate diversity as it takes a long time.
-  // Accept every created GP
-  virtual int checkForValidCreation (GP&) { return 1; }
-
-  virtual GP* createGP (int numOfGenes) { return new MyGP (numOfGenes); }
-};
-
-
diff -urN gpc++0.5.2_oryg/symbreg/symbreg.ini gpc++0.5.2/symbreg/symbreg.ini
--- gpc++0.5.2_oryg/symbreg/symbreg.ini	1997-02-16 13:51:27.000000000 +0100
+++ gpc++0.5.2/symbreg/symbreg.ini	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-# Configuration (created by class configuration)
-PopulationSize                  = 300
-NumberOfGenerations             = 20
-CreationType			= 2
-CreationProbability             = 0.0
-CrossoverProbability            = 100.0
-MaximumDepthForCreation         = 6
-MaximumDepthForCrossover        = 17
-SelectionType                   = 1
-TournamentSize                  = 20
-DemeticGrouping                 = 0
-DemeSize                        = 100
-DemeticMigProbability           = 100.0
-SwapMutationProbability         = 3.0
-ShrinkMutationProbability       = 3.0
-SteadyState			= 0
-InfoFileName                    = result
-AddBestToNewPopulation		= 1
